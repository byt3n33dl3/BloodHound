// This file was generated by MIG from Security-58286.220.15/OSX/libsecurityd/mig/ucsp.defs

//
// Copyright (c) 2004,2006-2007,2011 Apple Inc. All Rights Reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
//

/*
 * IDENTIFICATION:
 * stub generated Sat Jan 19 19:32:36 2019
 * with a MiG generated by bootstrap_cmds-96.20.2.200.4
 * OPTIONS: 
 */
#define	__MIG_check__Reply__ucsp_subsystem__ 1

#include "ucsp.hpp"


#ifndef	mig_internal
#define	mig_internal	static __inline__
#endif	/* mig_internal */

#ifndef	mig_external
#define mig_external
#endif	/* mig_external */

#if	!defined(__MigTypeCheck) && defined(TypeCheck)
#define	__MigTypeCheck		TypeCheck	/* Legacy setting */
#endif	/* !defined(__MigTypeCheck) */

#if	!defined(__MigKernelSpecificCode) && defined(_MIG_KERNEL_SPECIFIC_CODE_)
#define	__MigKernelSpecificCode	_MIG_KERNEL_SPECIFIC_CODE_	/* Legacy setting */
#endif	/* !defined(__MigKernelSpecificCode) */

#ifndef	LimitCheck
#define	LimitCheck 0
#endif	/* LimitCheck */

#ifndef	min
#define	min(a,b)  ( ((a) < (b))? (a): (b) )
#endif	/* min */

#if !defined(_WALIGN_)
#define _WALIGN_(x) (((x) + 3) & ~3)
#endif /* !defined(_WALIGN_) */

#if !defined(_WALIGNSZ_)
#define _WALIGNSZ_(x) _WALIGN_(sizeof(x))
#endif /* !defined(_WALIGNSZ_) */

#ifndef	UseStaticTemplates
#define	UseStaticTemplates	0
#endif	/* UseStaticTemplates */

#ifndef	__MachMsgErrorWithTimeout
#define	__MachMsgErrorWithTimeout(_R_) { \
	switch (_R_) { \
	case MACH_SEND_INVALID_DATA: \
	case MACH_SEND_INVALID_DEST: \
	case MACH_SEND_INVALID_HEADER: \
		mig_put_reply_port(InP->Head.msgh_reply_port); \
		break; \
	case MACH_SEND_TIMED_OUT: \
	case MACH_RCV_TIMED_OUT: \
	default: \
		mig_dealloc_reply_port(InP->Head.msgh_reply_port); \
	} \
}
#endif	/* __MachMsgErrorWithTimeout */

#ifndef	__MachMsgErrorWithoutTimeout
#define	__MachMsgErrorWithoutTimeout(_R_) { \
	switch (_R_) { \
	case MACH_SEND_INVALID_DATA: \
	case MACH_SEND_INVALID_DEST: \
	case MACH_SEND_INVALID_HEADER: \
		mig_put_reply_port(InP->Head.msgh_reply_port); \
		break; \
	default: \
		mig_dealloc_reply_port(InP->Head.msgh_reply_port); \
	} \
}
#endif	/* __MachMsgErrorWithoutTimeout */

#ifndef	__DeclareSendRpc
#define	__DeclareSendRpc(_NUM_, _NAME_)
#endif	/* __DeclareSendRpc */

#ifndef	__BeforeSendRpc
#define	__BeforeSendRpc(_NUM_, _NAME_)
#endif	/* __BeforeSendRpc */

#ifndef	__AfterSendRpc
#define	__AfterSendRpc(_NUM_, _NAME_)
#endif	/* __AfterSendRpc */

#ifndef	__DeclareSendSimple
#define	__DeclareSendSimple(_NUM_, _NAME_)
#endif	/* __DeclareSendSimple */

#ifndef	__BeforeSendSimple
#define	__BeforeSendSimple(_NUM_, _NAME_)
#endif	/* __BeforeSendSimple */

#ifndef	__AfterSendSimple
#define	__AfterSendSimple(_NUM_, _NAME_)
#endif	/* __AfterSendSimple */

#define msgh_request_port	msgh_remote_port
#define msgh_reply_port		msgh_local_port



#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__setup_t__defined)
#define __MIG_check__Reply__setup_t__defined

mig_internal kern_return_t __MIG_check__Reply__setup_t(__Reply__setup_t *Out0P)
{

	typedef __Reply__setup_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1100) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__setup_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine setup */
mig_external kern_return_t ucsp_client_setup
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	mach_port_t tport,
	ClientSetupInfo info,
	FilePath FilePath
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t tport;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		ClientSetupInfo info;
		mach_msg_type_number_t FilePathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t FilePathCnt;
		char FilePath[1024];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__setup_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__setup_t__defined */

	__DeclareSendRpc(1000, "setup")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t tportTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->tport = tportTemplate;
	InP->tport.name = tport;
#else	/* UseStaticTemplates */
	InP->tport.name = tport;
	InP->tport.disposition = 19;
	InP->tport.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->info = info;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->FilePathCnt = mig_strncpy_zerofill(InP->FilePath, FilePath, 1024);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->FilePathCnt = mig_strncpy(InP->FilePath, FilePath, 1024);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 1024) + (_WALIGN_(InP->FilePathCnt));
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1000;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1000, "setup")
    msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1000, "setup")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__setup_t__defined)
	check_result = __MIG_check__Reply__setup_t((__Reply__setup_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__setup_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__setupThread_t__defined)
#define __MIG_check__Reply__setupThread_t__defined

mig_internal kern_return_t __MIG_check__Reply__setupThread_t(__Reply__setupThread_t *Out0P)
{

	typedef __Reply__setupThread_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1102) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__setupThread_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine setupThread */
mig_external kern_return_t ucsp_client_setupThread
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
    mach_port_t tport
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t tport;
		/* end of the kernel processed data */
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__setupThread_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__setupThread_t__defined */

	__DeclareSendRpc(1002, "setupThread")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t tportTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->tport = tportTemplate;
	InP->tport.name = tport;
#else	/* UseStaticTemplates */
	InP->tport.name = tport;
	InP->tport.disposition = 19;
	InP->tport.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 19);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1002;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1002, "setupThread")
    msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1002, "setupThread")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__setupThread_t__defined)
	check_result = __MIG_check__Reply__setupThread_t((__Reply__setupThread_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__setupThread_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__authenticateDb_t__defined)
#define __MIG_check__Reply__authenticateDb_t__defined

mig_internal kern_return_t __MIG_check__Reply__authenticateDb_t(__Reply__authenticateDb_t *Out0P)
{

	typedef __Reply__authenticateDb_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1103) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__authenticateDb_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine authenticateDb */
mig_external kern_return_t ucsp_client_authenticateDb
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	CSSM_DB_ACCESS_TYPE accessType,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t accessCredentials;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		CSSM_DB_ACCESS_TYPE accessType;
		mach_msg_type_number_t accessCredentialsCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__authenticateDb_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__authenticateDb_t__defined */

	__DeclareSendRpc(1003, "authenticateDb")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t accessCredentialsTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->accessCredentials = accessCredentialsTemplate;
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
#else	/* UseStaticTemplates */
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
	InP->accessCredentials.deallocate =  FALSE;
	InP->accessCredentials.copy = MACH_MSG_VIRTUAL_COPY;
	InP->accessCredentials.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->db = db;

	InP->accessType = accessType;

	InP->accessCredentialsCnt = accessCredentialsCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1003;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1003, "authenticateDb")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1003, "authenticateDb")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__authenticateDb_t__defined)
	check_result = __MIG_check__Reply__authenticateDb_t((__Reply__authenticateDb_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__authenticateDb_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__releaseDb_t__defined)
#define __MIG_check__Reply__releaseDb_t__defined

mig_internal kern_return_t __MIG_check__Reply__releaseDb_t(__Reply__releaseDb_t *Out0P)
{

	typedef __Reply__releaseDb_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1104) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__releaseDb_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine releaseDb */
mig_external kern_return_t ucsp_client_releaseDb
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__releaseDb_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__releaseDb_t__defined */

	__DeclareSendRpc(1004, "releaseDb")

	InP->NDR = NDR_record;

	InP->db = db;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1004;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1004, "releaseDb")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1004, "releaseDb")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__releaseDb_t__defined)
	check_result = __MIG_check__Reply__releaseDb_t((__Reply__releaseDb_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__releaseDb_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__getDbName_t__defined)
#define __MIG_check__Reply__getDbName_t__defined

mig_internal kern_return_t __MIG_check__Reply__getDbName_t(__Reply__getDbName_t *Out0P)
{

	typedef __Reply__getDbName_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

	if (Out0P->Head.msgh_id != 1105) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size > (mach_msg_size_t)sizeof(__Reply) || msgh_size < (mach_msg_size_t)(sizeof(__Reply) - 1024)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if ( Out0P->nameCnt > 1024 )
		return MIG_TYPE_ERROR;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Reply) - 1024))< Out0P->nameCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Reply) - 1024) + _WALIGN_(Out0P->nameCnt)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__getDbName_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine getDbName */
mig_external kern_return_t ucsp_client_getDbName
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	FilePathOut name
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[1024];
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[1024];
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__getDbName_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__getDbName_t__defined */

	__DeclareSendRpc(1005, "getDbName")

	InP->NDR = NDR_record;

	InP->db = db;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1005;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1005, "getDbName")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1005, "getDbName")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__getDbName_t__defined)
	check_result = __MIG_check__Reply__getDbName_t((__Reply__getDbName_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__getDbName_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	(void) mig_strncpy(name, Out0P->name, 1024);

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__setDbName_t__defined)
#define __MIG_check__Reply__setDbName_t__defined

mig_internal kern_return_t __MIG_check__Reply__setDbName_t(__Reply__setDbName_t *Out0P)
{

	typedef __Reply__setDbName_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1106) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__setDbName_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine setDbName */
mig_external kern_return_t ucsp_client_setDbName
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	FilePath name
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[1024];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__setDbName_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__setDbName_t__defined */

	__DeclareSendRpc(1006, "setDbName")

	InP->NDR = NDR_record;

	InP->db = db;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->nameCnt = mig_strncpy_zerofill(InP->name, name, 1024);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->nameCnt = mig_strncpy(InP->name, name, 1024);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 1024) + (_WALIGN_(InP->nameCnt));
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1006;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1006, "setDbName")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1006, "setDbName")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__setDbName_t__defined)
	check_result = __MIG_check__Reply__setDbName_t((__Reply__setDbName_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__setDbName_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__openToken_t__defined)
#define __MIG_check__Reply__openToken_t__defined

mig_internal kern_return_t __MIG_check__Reply__openToken_t(__Reply__openToken_t *Out0P)
{

	typedef __Reply__openToken_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1107) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__openToken_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine openToken */
mig_external kern_return_t ucsp_client_openToken
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	uint32 ssid,
	FilePath name,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	IPCDbHandle *db
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t accessCredentials;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32 ssid;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[1024];
		mach_msg_type_number_t accessCredentialsCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle db;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle db;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;

	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__openToken_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__openToken_t__defined */

	__DeclareSendRpc(1007, "openToken")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t accessCredentialsTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->accessCredentials = accessCredentialsTemplate;
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
#else	/* UseStaticTemplates */
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
	InP->accessCredentials.deallocate =  FALSE;
	InP->accessCredentials.copy = MACH_MSG_VIRTUAL_COPY;
	InP->accessCredentials.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->ssid = ssid;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->nameCnt = mig_strncpy_zerofill(InP->name, name, 1024);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->nameCnt = mig_strncpy(InP->name, name, 1024);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */

	msgh_size_delta = _WALIGN_(InP->nameCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 1024) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 1024);

	InP->accessCredentialsCnt = accessCredentialsCnt;

	InP = &Mess.In;
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1007;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1007, "openToken")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1007, "openToken")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__openToken_t__defined)
	check_result = __MIG_check__Reply__openToken_t((__Reply__openToken_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__openToken_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*db = Out0P->db;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__findFirst_t__defined)
#define __MIG_check__Reply__findFirst_t__defined

mig_internal kern_return_t __MIG_check__Reply__findFirst_t(__Reply__findFirst_t *Out0P)
{

	typedef __Reply__findFirst_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1108) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 2 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->outAttributes.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->data.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->outAttributes.size != Out0P->outAttributesCnt)
		return MIG_TYPE_ERROR;
	if (Out0P->data.size != Out0P->dataCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__findFirst_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine findFirst */
mig_external kern_return_t ucsp_client_findFirst
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	Data query,
	mach_msg_type_number_t queryCnt,
	Data inAttributes,
	mach_msg_type_number_t inAttributesCnt,
	Data *outAttributes,
	mach_msg_type_number_t *outAttributesCnt,
	boolean_t getData,
	Data *data,
	mach_msg_type_number_t *dataCnt,
	IPCKeyHandle *key,
	IPCSearchHandle *search,
	IPCRecordHandle *record
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t query;
		mach_msg_ool_descriptor_t inAttributes;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t queryCnt;
		mach_msg_type_number_t inAttributesCnt;
		boolean_t getData;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t outAttributes;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t outAttributesCnt;
		mach_msg_type_number_t dataCnt;
		IPCKeyHandle key;
		IPCSearchHandle search;
		IPCRecordHandle record;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t outAttributes;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t outAttributesCnt;
		mach_msg_type_number_t dataCnt;
		IPCKeyHandle key;
		IPCSearchHandle search;
		IPCRecordHandle record;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__findFirst_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__findFirst_t__defined */

	__DeclareSendRpc(1008, "findFirst")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t queryTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t inAttributesTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 2;
#if	UseStaticTemplates
	InP->query = queryTemplate;
	InP->query.address = (void *)(query);
	InP->query.size = queryCnt;
#else	/* UseStaticTemplates */
	InP->query.address = (void *)(query);
	InP->query.size = queryCnt;
	InP->query.deallocate =  FALSE;
	InP->query.copy = MACH_MSG_VIRTUAL_COPY;
	InP->query.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->inAttributes = inAttributesTemplate;
	InP->inAttributes.address = (void *)(inAttributes);
	InP->inAttributes.size = inAttributesCnt;
#else	/* UseStaticTemplates */
	InP->inAttributes.address = (void *)(inAttributes);
	InP->inAttributes.size = inAttributesCnt;
	InP->inAttributes.deallocate =  FALSE;
	InP->inAttributes.copy = MACH_MSG_VIRTUAL_COPY;
	InP->inAttributes.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->db = db;

	InP->queryCnt = queryCnt;

	InP->inAttributesCnt = inAttributesCnt;

	InP->getData = getData;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1008;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1008, "findFirst")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1008, "findFirst")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__findFirst_t__defined)
	check_result = __MIG_check__Reply__findFirst_t((__Reply__findFirst_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__findFirst_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*outAttributes = (Data)(Out0P->outAttributes.address);
	*outAttributesCnt = Out0P->outAttributesCnt;

	*data = (Data)(Out0P->data.address);
	*dataCnt = Out0P->dataCnt;

	*key = Out0P->key;

	*search = Out0P->search;

	*record = Out0P->record;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__findNext_t__defined)
#define __MIG_check__Reply__findNext_t__defined

mig_internal kern_return_t __MIG_check__Reply__findNext_t(__Reply__findNext_t *Out0P)
{

	typedef __Reply__findNext_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1109) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 2 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->outAttributes.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->data.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->outAttributes.size != Out0P->outAttributesCnt)
		return MIG_TYPE_ERROR;
	if (Out0P->data.size != Out0P->dataCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__findNext_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine findNext */
mig_external kern_return_t ucsp_client_findNext
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCSearchHandle search,
	Data inAttributes,
	mach_msg_type_number_t inAttributesCnt,
	Data *outAttributes,
	mach_msg_type_number_t *outAttributesCnt,
	boolean_t getData,
	Data *data,
	mach_msg_type_number_t *dataCnt,
	IPCKeyHandle *key,
	IPCRecordHandle *record
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t inAttributes;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCSearchHandle search;
		mach_msg_type_number_t inAttributesCnt;
		boolean_t getData;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t outAttributes;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t outAttributesCnt;
		mach_msg_type_number_t dataCnt;
		IPCKeyHandle key;
		IPCRecordHandle record;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t outAttributes;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t outAttributesCnt;
		mach_msg_type_number_t dataCnt;
		IPCKeyHandle key;
		IPCRecordHandle record;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__findNext_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__findNext_t__defined */

	__DeclareSendRpc(1009, "findNext")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t inAttributesTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->inAttributes = inAttributesTemplate;
	InP->inAttributes.address = (void *)(inAttributes);
	InP->inAttributes.size = inAttributesCnt;
#else	/* UseStaticTemplates */
	InP->inAttributes.address = (void *)(inAttributes);
	InP->inAttributes.size = inAttributesCnt;
	InP->inAttributes.deallocate =  FALSE;
	InP->inAttributes.copy = MACH_MSG_VIRTUAL_COPY;
	InP->inAttributes.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->search = search;

	InP->inAttributesCnt = inAttributesCnt;

	InP->getData = getData;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1009;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1009, "findNext")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1009, "findNext")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__findNext_t__defined)
	check_result = __MIG_check__Reply__findNext_t((__Reply__findNext_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__findNext_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*outAttributes = (Data)(Out0P->outAttributes.address);
	*outAttributesCnt = Out0P->outAttributesCnt;

	*data = (Data)(Out0P->data.address);
	*dataCnt = Out0P->dataCnt;

	*key = Out0P->key;

	*record = Out0P->record;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__findRecordHandle_t__defined)
#define __MIG_check__Reply__findRecordHandle_t__defined

mig_internal kern_return_t __MIG_check__Reply__findRecordHandle_t(__Reply__findRecordHandle_t *Out0P)
{

	typedef __Reply__findRecordHandle_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1110) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 2 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->outAttributes.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->data.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->outAttributes.size != Out0P->outAttributesCnt)
		return MIG_TYPE_ERROR;
	if (Out0P->data.size != Out0P->dataCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__findRecordHandle_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine findRecordHandle */
mig_external kern_return_t ucsp_client_findRecordHandle
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCRecordHandle record,
	Data inAttributes,
	mach_msg_type_number_t inAttributesCnt,
	Data *outAttributes,
	mach_msg_type_number_t *outAttributesCnt,
	boolean_t getData,
	Data *data,
	mach_msg_type_number_t *dataCnt,
	IPCKeyHandle *key
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t inAttributes;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCRecordHandle record;
		mach_msg_type_number_t inAttributesCnt;
		boolean_t getData;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t outAttributes;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t outAttributesCnt;
		mach_msg_type_number_t dataCnt;
		IPCKeyHandle key;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t outAttributes;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t outAttributesCnt;
		mach_msg_type_number_t dataCnt;
		IPCKeyHandle key;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__findRecordHandle_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__findRecordHandle_t__defined */

	__DeclareSendRpc(1010, "findRecordHandle")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t inAttributesTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->inAttributes = inAttributesTemplate;
	InP->inAttributes.address = (void *)(inAttributes);
	InP->inAttributes.size = inAttributesCnt;
#else	/* UseStaticTemplates */
	InP->inAttributes.address = (void *)(inAttributes);
	InP->inAttributes.size = inAttributesCnt;
	InP->inAttributes.deallocate =  FALSE;
	InP->inAttributes.copy = MACH_MSG_VIRTUAL_COPY;
	InP->inAttributes.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->record = record;

	InP->inAttributesCnt = inAttributesCnt;

	InP->getData = getData;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1010;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1010, "findRecordHandle")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1010, "findRecordHandle")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__findRecordHandle_t__defined)
	check_result = __MIG_check__Reply__findRecordHandle_t((__Reply__findRecordHandle_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__findRecordHandle_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*outAttributes = (Data)(Out0P->outAttributes.address);
	*outAttributesCnt = Out0P->outAttributesCnt;

	*data = (Data)(Out0P->data.address);
	*dataCnt = Out0P->dataCnt;

	*key = Out0P->key;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__insertRecord_t__defined)
#define __MIG_check__Reply__insertRecord_t__defined

mig_internal kern_return_t __MIG_check__Reply__insertRecord_t(__Reply__insertRecord_t *Out0P)
{

	typedef __Reply__insertRecord_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1111) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__insertRecord_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine insertRecord */
mig_external kern_return_t ucsp_client_insertRecord
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	CSSM_DB_RECORDTYPE recordType,
	Data attributes,
	mach_msg_type_number_t attributesCnt,
	Data data,
	mach_msg_type_number_t dataCnt,
	IPCRecordHandle *record
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t attributes;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		CSSM_DB_RECORDTYPE recordType;
		mach_msg_type_number_t attributesCnt;
		mach_msg_type_number_t dataCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCRecordHandle record;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCRecordHandle record;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__insertRecord_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__insertRecord_t__defined */

	__DeclareSendRpc(1011, "insertRecord")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t attributesTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t dataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 2;
#if	UseStaticTemplates
	InP->attributes = attributesTemplate;
	InP->attributes.address = (void *)(attributes);
	InP->attributes.size = attributesCnt;
#else	/* UseStaticTemplates */
	InP->attributes.address = (void *)(attributes);
	InP->attributes.size = attributesCnt;
	InP->attributes.deallocate =  FALSE;
	InP->attributes.copy = MACH_MSG_VIRTUAL_COPY;
	InP->attributes.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->data = dataTemplate;
	InP->data.address = (void *)(data);
	InP->data.size = dataCnt;
#else	/* UseStaticTemplates */
	InP->data.address = (void *)(data);
	InP->data.size = dataCnt;
	InP->data.deallocate =  FALSE;
	InP->data.copy = MACH_MSG_VIRTUAL_COPY;
	InP->data.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->db = db;

	InP->recordType = recordType;

	InP->attributesCnt = attributesCnt;

	InP->dataCnt = dataCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1011;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1011, "insertRecord")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1011, "insertRecord")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__insertRecord_t__defined)
	check_result = __MIG_check__Reply__insertRecord_t((__Reply__insertRecord_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__insertRecord_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*record = Out0P->record;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__deleteRecord_t__defined)
#define __MIG_check__Reply__deleteRecord_t__defined

mig_internal kern_return_t __MIG_check__Reply__deleteRecord_t(__Reply__deleteRecord_t *Out0P)
{

	typedef __Reply__deleteRecord_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1112) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__deleteRecord_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine deleteRecord */
mig_external kern_return_t ucsp_client_deleteRecord
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	IPCRecordHandle record
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
		IPCRecordHandle record;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__deleteRecord_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__deleteRecord_t__defined */

	__DeclareSendRpc(1012, "deleteRecord")

	InP->NDR = NDR_record;

	InP->db = db;

	InP->record = record;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1012;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1012, "deleteRecord")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1012, "deleteRecord")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__deleteRecord_t__defined)
	check_result = __MIG_check__Reply__deleteRecord_t((__Reply__deleteRecord_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__deleteRecord_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__modifyRecord_t__defined)
#define __MIG_check__Reply__modifyRecord_t__defined

mig_internal kern_return_t __MIG_check__Reply__modifyRecord_t(__Reply__modifyRecord_t *Out0P)
{

	typedef __Reply__modifyRecord_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1113) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__modifyRecord_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine modifyRecord */
mig_external kern_return_t ucsp_client_modifyRecord
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	IPCRecordHandle *record,
	CSSM_DB_RECORDTYPE recordType,
	Data attributes,
	mach_msg_type_number_t attributesCnt,
	boolean_t setData,
	Data data,
	mach_msg_type_number_t dataCnt,
	CSSM_DB_MODIFY_MODE modifyMode
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t attributes;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		IPCRecordHandle record;
		CSSM_DB_RECORDTYPE recordType;
		mach_msg_type_number_t attributesCnt;
		boolean_t setData;
		mach_msg_type_number_t dataCnt;
		CSSM_DB_MODIFY_MODE modifyMode;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCRecordHandle record;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCRecordHandle record;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__modifyRecord_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__modifyRecord_t__defined */

	__DeclareSendRpc(1013, "modifyRecord")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t attributesTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t dataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 2;
#if	UseStaticTemplates
	InP->attributes = attributesTemplate;
	InP->attributes.address = (void *)(attributes);
	InP->attributes.size = attributesCnt;
#else	/* UseStaticTemplates */
	InP->attributes.address = (void *)(attributes);
	InP->attributes.size = attributesCnt;
	InP->attributes.deallocate =  FALSE;
	InP->attributes.copy = MACH_MSG_VIRTUAL_COPY;
	InP->attributes.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->data = dataTemplate;
	InP->data.address = (void *)(data);
	InP->data.size = dataCnt;
#else	/* UseStaticTemplates */
	InP->data.address = (void *)(data);
	InP->data.size = dataCnt;
	InP->data.deallocate =  FALSE;
	InP->data.copy = MACH_MSG_VIRTUAL_COPY;
	InP->data.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->db = db;

	InP->record = *record;

	InP->recordType = recordType;

	InP->attributesCnt = attributesCnt;

	InP->setData = setData;

	InP->dataCnt = dataCnt;

	InP->modifyMode = modifyMode;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1013;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1013, "modifyRecord")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1013, "modifyRecord")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__modifyRecord_t__defined)
	check_result = __MIG_check__Reply__modifyRecord_t((__Reply__modifyRecord_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__modifyRecord_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*record = Out0P->record;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__releaseSearch_t__defined)
#define __MIG_check__Reply__releaseSearch_t__defined

mig_internal kern_return_t __MIG_check__Reply__releaseSearch_t(__Reply__releaseSearch_t *Out0P)
{

	typedef __Reply__releaseSearch_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1114) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__releaseSearch_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine releaseSearch */
mig_external kern_return_t ucsp_client_releaseSearch
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCSearchHandle search
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCSearchHandle search;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__releaseSearch_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__releaseSearch_t__defined */

	__DeclareSendRpc(1014, "releaseSearch")

	InP->NDR = NDR_record;

	InP->search = search;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1014;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1014, "releaseSearch")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1014, "releaseSearch")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__releaseSearch_t__defined)
	check_result = __MIG_check__Reply__releaseSearch_t((__Reply__releaseSearch_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__releaseSearch_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__releaseRecord_t__defined)
#define __MIG_check__Reply__releaseRecord_t__defined

mig_internal kern_return_t __MIG_check__Reply__releaseRecord_t(__Reply__releaseRecord_t *Out0P)
{

	typedef __Reply__releaseRecord_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1115) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__releaseRecord_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine releaseRecord */
mig_external kern_return_t ucsp_client_releaseRecord
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCRecordHandle record
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCRecordHandle record;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__releaseRecord_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__releaseRecord_t__defined */

	__DeclareSendRpc(1015, "releaseRecord")

	InP->NDR = NDR_record;

	InP->record = record;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1015;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1015, "releaseRecord")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1015, "releaseRecord")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__releaseRecord_t__defined)
	check_result = __MIG_check__Reply__releaseRecord_t((__Reply__releaseRecord_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__releaseRecord_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__createDb_t__defined)
#define __MIG_check__Reply__createDb_t__defined

mig_internal kern_return_t __MIG_check__Reply__createDb_t(__Reply__createDb_t *Out0P)
{

	typedef __Reply__createDb_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1116) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__createDb_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine createDb */
mig_external kern_return_t ucsp_client_createDb
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle *db,
	Data ident,
	mach_msg_type_number_t identCnt,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	Data aclEntryPrototype,
	mach_msg_type_number_t aclEntryPrototypeCnt,
	DBParameters params
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t ident;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryPrototype;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t identCnt;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclEntryPrototypeCnt;
		DBParameters params;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle db;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle db;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__createDb_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__createDb_t__defined */

	__DeclareSendRpc(1016, "createDb")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t identTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t accessCredentialsTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t aclEntryPrototypeTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 3;
#if	UseStaticTemplates
	InP->ident = identTemplate;
	InP->ident.address = (void *)(ident);
	InP->ident.size = identCnt;
#else	/* UseStaticTemplates */
	InP->ident.address = (void *)(ident);
	InP->ident.size = identCnt;
	InP->ident.deallocate =  FALSE;
	InP->ident.copy = MACH_MSG_VIRTUAL_COPY;
	InP->ident.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->accessCredentials = accessCredentialsTemplate;
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
#else	/* UseStaticTemplates */
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
	InP->accessCredentials.deallocate =  FALSE;
	InP->accessCredentials.copy = MACH_MSG_VIRTUAL_COPY;
	InP->accessCredentials.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->aclEntryPrototype = aclEntryPrototypeTemplate;
	InP->aclEntryPrototype.address = (void *)(aclEntryPrototype);
	InP->aclEntryPrototype.size = aclEntryPrototypeCnt;
#else	/* UseStaticTemplates */
	InP->aclEntryPrototype.address = (void *)(aclEntryPrototype);
	InP->aclEntryPrototype.size = aclEntryPrototypeCnt;
	InP->aclEntryPrototype.deallocate =  FALSE;
	InP->aclEntryPrototype.copy = MACH_MSG_VIRTUAL_COPY;
	InP->aclEntryPrototype.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->identCnt = identCnt;

	InP->accessCredentialsCnt = accessCredentialsCnt;

	InP->aclEntryPrototypeCnt = aclEntryPrototypeCnt;

	InP->params = params;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1016;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1016, "createDb")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1016, "createDb")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__createDb_t__defined)
	check_result = __MIG_check__Reply__createDb_t((__Reply__createDb_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__createDb_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*db = Out0P->db;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__decodeDb_t__defined)
#define __MIG_check__Reply__decodeDb_t__defined

mig_internal kern_return_t __MIG_check__Reply__decodeDb_t(__Reply__decodeDb_t *Out0P)
{

	typedef __Reply__decodeDb_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1118) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__decodeDb_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine decodeDb */
mig_external kern_return_t ucsp_client_decodeDb
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle *db,
	Data ident,
	mach_msg_type_number_t identCnt,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	Pointer blob,
	mach_msg_type_number_t blobCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t ident;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t blob;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t identCnt;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t blobCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle db;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle db;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__decodeDb_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__decodeDb_t__defined */

	__DeclareSendRpc(1018, "decodeDb")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t identTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t accessCredentialsTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t blobTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 3;
#if	UseStaticTemplates
	InP->ident = identTemplate;
	InP->ident.address = (void *)(ident);
	InP->ident.size = identCnt;
#else	/* UseStaticTemplates */
	InP->ident.address = (void *)(ident);
	InP->ident.size = identCnt;
	InP->ident.deallocate =  FALSE;
	InP->ident.copy = MACH_MSG_VIRTUAL_COPY;
	InP->ident.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->accessCredentials = accessCredentialsTemplate;
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
#else	/* UseStaticTemplates */
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
	InP->accessCredentials.deallocate =  FALSE;
	InP->accessCredentials.copy = MACH_MSG_VIRTUAL_COPY;
	InP->accessCredentials.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->blob = blobTemplate;
	InP->blob.address = (void *)(blob);
	InP->blob.size = blobCnt;
#else	/* UseStaticTemplates */
	InP->blob.address = (void *)(blob);
	InP->blob.size = blobCnt;
	InP->blob.deallocate =  FALSE;
	InP->blob.copy = MACH_MSG_VIRTUAL_COPY;
	InP->blob.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->identCnt = identCnt;

	InP->accessCredentialsCnt = accessCredentialsCnt;

	InP->blobCnt = blobCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1018;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1018, "decodeDb")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1018, "decodeDb")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__decodeDb_t__defined)
	check_result = __MIG_check__Reply__decodeDb_t((__Reply__decodeDb_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__decodeDb_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*db = Out0P->db;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__encodeDb_t__defined)
#define __MIG_check__Reply__encodeDb_t__defined

mig_internal kern_return_t __MIG_check__Reply__encodeDb_t(__Reply__encodeDb_t *Out0P)
{

	typedef __Reply__encodeDb_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1119) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->blob.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->blob.size != Out0P->blobCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__encodeDb_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine encodeDb */
mig_external kern_return_t ucsp_client_encodeDb
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	Pointer *blob,
	mach_msg_type_number_t *blobCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t blob;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t blobCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t blob;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t blobCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__encodeDb_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__encodeDb_t__defined */

	__DeclareSendRpc(1019, "encodeDb")

	InP->NDR = NDR_record;

	InP->db = db;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1019;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1019, "encodeDb")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1019, "encodeDb")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__encodeDb_t__defined)
	check_result = __MIG_check__Reply__encodeDb_t((__Reply__encodeDb_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__encodeDb_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*blob = (Pointer)(Out0P->blob.address);
	*blobCnt = Out0P->blobCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__setDbParameters_t__defined)
#define __MIG_check__Reply__setDbParameters_t__defined

mig_internal kern_return_t __MIG_check__Reply__setDbParameters_t(__Reply__setDbParameters_t *Out0P)
{

	typedef __Reply__setDbParameters_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1120) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__setDbParameters_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine setDbParameters */
mig_external kern_return_t ucsp_client_setDbParameters
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	DBParameters params
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
		DBParameters params;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__setDbParameters_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__setDbParameters_t__defined */

	__DeclareSendRpc(1020, "setDbParameters")

	InP->NDR = NDR_record;

	InP->db = db;

	InP->params = params;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1020;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1020, "setDbParameters")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1020, "setDbParameters")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__setDbParameters_t__defined)
	check_result = __MIG_check__Reply__setDbParameters_t((__Reply__setDbParameters_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__setDbParameters_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__getDbParameters_t__defined)
#define __MIG_check__Reply__getDbParameters_t__defined

mig_internal kern_return_t __MIG_check__Reply__getDbParameters_t(__Reply__getDbParameters_t *Out0P)
{

	typedef __Reply__getDbParameters_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1121) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__getDbParameters_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine getDbParameters */
mig_external kern_return_t ucsp_client_getDbParameters
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	DBParameters *params
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		DBParameters params;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		DBParameters params;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__getDbParameters_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__getDbParameters_t__defined */

	__DeclareSendRpc(1021, "getDbParameters")

	InP->NDR = NDR_record;

	InP->db = db;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1021;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1021, "getDbParameters")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1021, "getDbParameters")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__getDbParameters_t__defined)
	check_result = __MIG_check__Reply__getDbParameters_t((__Reply__getDbParameters_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__getDbParameters_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*params = Out0P->params;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__changePassphrase_t__defined)
#define __MIG_check__Reply__changePassphrase_t__defined

mig_internal kern_return_t __MIG_check__Reply__changePassphrase_t(__Reply__changePassphrase_t *Out0P)
{

	typedef __Reply__changePassphrase_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1122) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__changePassphrase_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine changePassphrase */
mig_external kern_return_t ucsp_client_changePassphrase
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t accessCredentials;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t accessCredentialsCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__changePassphrase_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__changePassphrase_t__defined */

	__DeclareSendRpc(1022, "changePassphrase")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t accessCredentialsTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->accessCredentials = accessCredentialsTemplate;
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
#else	/* UseStaticTemplates */
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
	InP->accessCredentials.deallocate =  FALSE;
	InP->accessCredentials.copy = MACH_MSG_VIRTUAL_COPY;
	InP->accessCredentials.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->db = db;

	InP->accessCredentialsCnt = accessCredentialsCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1022;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1022, "changePassphrase")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1022, "changePassphrase")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__changePassphrase_t__defined)
	check_result = __MIG_check__Reply__changePassphrase_t((__Reply__changePassphrase_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__changePassphrase_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__lockAll_t__defined)
#define __MIG_check__Reply__lockAll_t__defined

mig_internal kern_return_t __MIG_check__Reply__lockAll_t(__Reply__lockAll_t *Out0P)
{

	typedef __Reply__lockAll_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1123) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__lockAll_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine lockAll */
mig_external kern_return_t ucsp_client_lockAll
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	boolean_t forSleep
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		boolean_t forSleep;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__lockAll_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__lockAll_t__defined */

	__DeclareSendRpc(1023, "lockAll")

	InP->NDR = NDR_record;

	InP->forSleep = forSleep;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1023;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1023, "lockAll")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1023, "lockAll")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__lockAll_t__defined)
	check_result = __MIG_check__Reply__lockAll_t((__Reply__lockAll_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__lockAll_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__unlockDb_t__defined)
#define __MIG_check__Reply__unlockDb_t__defined

mig_internal kern_return_t __MIG_check__Reply__unlockDb_t(__Reply__unlockDb_t *Out0P)
{

	typedef __Reply__unlockDb_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1124) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__unlockDb_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine unlockDb */
mig_external kern_return_t ucsp_client_unlockDb
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__unlockDb_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__unlockDb_t__defined */

	__DeclareSendRpc(1024, "unlockDb")

	InP->NDR = NDR_record;

	InP->db = db;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1024;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1024, "unlockDb")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1024, "unlockDb")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__unlockDb_t__defined)
	check_result = __MIG_check__Reply__unlockDb_t((__Reply__unlockDb_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__unlockDb_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__unlockDbWithPassphrase_t__defined)
#define __MIG_check__Reply__unlockDbWithPassphrase_t__defined

mig_internal kern_return_t __MIG_check__Reply__unlockDbWithPassphrase_t(__Reply__unlockDbWithPassphrase_t *Out0P)
{

	typedef __Reply__unlockDbWithPassphrase_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1125) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__unlockDbWithPassphrase_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine unlockDbWithPassphrase */
mig_external kern_return_t ucsp_client_unlockDbWithPassphrase
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	Data passPhrase,
	mach_msg_type_number_t passPhraseCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t passPhrase;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t passPhraseCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__unlockDbWithPassphrase_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__unlockDbWithPassphrase_t__defined */

	__DeclareSendRpc(1025, "unlockDbWithPassphrase")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t passPhraseTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->passPhrase = passPhraseTemplate;
	InP->passPhrase.address = (void *)(passPhrase);
	InP->passPhrase.size = passPhraseCnt;
#else	/* UseStaticTemplates */
	InP->passPhrase.address = (void *)(passPhrase);
	InP->passPhrase.size = passPhraseCnt;
	InP->passPhrase.deallocate =  FALSE;
	InP->passPhrase.copy = MACH_MSG_VIRTUAL_COPY;
	InP->passPhrase.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->db = db;

	InP->passPhraseCnt = passPhraseCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1025;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1025, "unlockDbWithPassphrase")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1025, "unlockDbWithPassphrase")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__unlockDbWithPassphrase_t__defined)
	check_result = __MIG_check__Reply__unlockDbWithPassphrase_t((__Reply__unlockDbWithPassphrase_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__unlockDbWithPassphrase_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__isLocked_t__defined)
#define __MIG_check__Reply__isLocked_t__defined

mig_internal kern_return_t __MIG_check__Reply__isLocked_t(__Reply__isLocked_t *Out0P)
{

	typedef __Reply__isLocked_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1126) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__isLocked_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine isLocked */
mig_external kern_return_t ucsp_client_isLocked
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	boolean_t *locked
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		boolean_t locked;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		boolean_t locked;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__isLocked_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__isLocked_t__defined */

	__DeclareSendRpc(1026, "isLocked")

	InP->NDR = NDR_record;

	InP->db = db;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1026;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1026, "isLocked")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1026, "isLocked")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__isLocked_t__defined)
	check_result = __MIG_check__Reply__isLocked_t((__Reply__isLocked_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__isLocked_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*locked = Out0P->locked;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__encodeKey_t__defined)
#define __MIG_check__Reply__encodeKey_t__defined

mig_internal kern_return_t __MIG_check__Reply__encodeKey_t(__Reply__encodeKey_t *Out0P)
{

	typedef __Reply__encodeKey_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1127) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 2 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->blob.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->uid.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->blob.size != Out0P->blobCnt)
		return MIG_TYPE_ERROR;
	if (Out0P->uid.size != Out0P->uidCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__encodeKey_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine encodeKey */
mig_external kern_return_t ucsp_client_encodeKey
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCKeyHandle key,
	Pointer *blob,
	mach_msg_type_number_t *blobCnt,
	boolean_t wantUid,
	Data *uid,
	mach_msg_type_number_t *uidCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCKeyHandle key;
		boolean_t wantUid;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t blob;
		mach_msg_ool_descriptor_t uid;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t blobCnt;
		mach_msg_type_number_t uidCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t blob;
		mach_msg_ool_descriptor_t uid;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t blobCnt;
		mach_msg_type_number_t uidCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__encodeKey_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__encodeKey_t__defined */

	__DeclareSendRpc(1027, "encodeKey")

	InP->NDR = NDR_record;

	InP->key = key;

	InP->wantUid = wantUid;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1027;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1027, "encodeKey")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1027, "encodeKey")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__encodeKey_t__defined)
	check_result = __MIG_check__Reply__encodeKey_t((__Reply__encodeKey_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__encodeKey_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*blob = (Pointer)(Out0P->blob.address);
	*blobCnt = Out0P->blobCnt;

	*uid = (Data)(Out0P->uid.address);
	*uidCnt = Out0P->uidCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__decodeKey_t__defined)
#define __MIG_check__Reply__decodeKey_t__defined

mig_internal kern_return_t __MIG_check__Reply__decodeKey_t(__Reply__decodeKey_t *Out0P)
{

	typedef __Reply__decodeKey_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1128) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->header.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->header.size != Out0P->headerCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__decodeKey_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine decodeKey */
mig_external kern_return_t ucsp_client_decodeKey
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCKeyHandle *key,
	Data *header,
	mach_msg_type_number_t *headerCnt,
	IPCDbHandle db,
	Pointer blob,
	mach_msg_type_number_t blobCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t blob;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t blobCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t header;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		IPCKeyHandle key;
		mach_msg_type_number_t headerCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t header;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		IPCKeyHandle key;
		mach_msg_type_number_t headerCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__decodeKey_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__decodeKey_t__defined */

	__DeclareSendRpc(1028, "decodeKey")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t blobTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->blob = blobTemplate;
	InP->blob.address = (void *)(blob);
	InP->blob.size = blobCnt;
#else	/* UseStaticTemplates */
	InP->blob.address = (void *)(blob);
	InP->blob.size = blobCnt;
	InP->blob.deallocate =  FALSE;
	InP->blob.copy = MACH_MSG_VIRTUAL_COPY;
	InP->blob.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->db = db;

	InP->blobCnt = blobCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1028;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1028, "decodeKey")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1028, "decodeKey")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__decodeKey_t__defined)
	check_result = __MIG_check__Reply__decodeKey_t((__Reply__decodeKey_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__decodeKey_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*key = Out0P->key;

	*header = (Data)(Out0P->header.address);
	*headerCnt = Out0P->headerCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__recodeKey_t__defined)
#define __MIG_check__Reply__recodeKey_t__defined

mig_internal kern_return_t __MIG_check__Reply__recodeKey_t(__Reply__recodeKey_t *Out0P)
{

	typedef __Reply__recodeKey_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1129) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->newBlob.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->newBlob.size != Out0P->newBlobCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__recodeKey_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine recodeKey */
mig_external kern_return_t ucsp_client_recodeKey
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle oldDb,
	IPCKeyHandle key,
	IPCDbHandle newDb,
	Pointer *newBlob,
	mach_msg_type_number_t *newBlobCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle oldDb;
		IPCKeyHandle key;
		IPCDbHandle newDb;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t newBlob;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t newBlobCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t newBlob;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t newBlobCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__recodeKey_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__recodeKey_t__defined */

	__DeclareSendRpc(1029, "recodeKey")

	InP->NDR = NDR_record;

	InP->oldDb = oldDb;

	InP->key = key;

	InP->newDb = newDb;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1029;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1029, "recodeKey")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1029, "recodeKey")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__recodeKey_t__defined)
	check_result = __MIG_check__Reply__recodeKey_t((__Reply__recodeKey_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__recodeKey_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*newBlob = (Pointer)(Out0P->newBlob.address);
	*newBlobCnt = Out0P->newBlobCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__releaseKey_t__defined)
#define __MIG_check__Reply__releaseKey_t__defined

mig_internal kern_return_t __MIG_check__Reply__releaseKey_t(__Reply__releaseKey_t *Out0P)
{

	typedef __Reply__releaseKey_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1130) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__releaseKey_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine releaseKey */
mig_external kern_return_t ucsp_client_releaseKey
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCKeyHandle key
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCKeyHandle key;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__releaseKey_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__releaseKey_t__defined */

	__DeclareSendRpc(1030, "releaseKey")

	InP->NDR = NDR_record;

	InP->key = key;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1030;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1030, "releaseKey")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1030, "releaseKey")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__releaseKey_t__defined)
	check_result = __MIG_check__Reply__releaseKey_t((__Reply__releaseKey_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__releaseKey_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__queryKeySizeInBits_t__defined)
#define __MIG_check__Reply__queryKeySizeInBits_t__defined

mig_internal kern_return_t __MIG_check__Reply__queryKeySizeInBits_t(__Reply__queryKeySizeInBits_t *Out0P)
{

	typedef __Reply__queryKeySizeInBits_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1131) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__queryKeySizeInBits_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine queryKeySizeInBits */
mig_external kern_return_t ucsp_client_queryKeySizeInBits
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCKeyHandle key,
	CSSM_KEY_SIZE *length
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCKeyHandle key;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		CSSM_KEY_SIZE length;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		CSSM_KEY_SIZE length;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__queryKeySizeInBits_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__queryKeySizeInBits_t__defined */

	__DeclareSendRpc(1031, "queryKeySizeInBits")

	InP->NDR = NDR_record;

	InP->key = key;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1031;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1031, "queryKeySizeInBits")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1031, "queryKeySizeInBits")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__queryKeySizeInBits_t__defined)
	check_result = __MIG_check__Reply__queryKeySizeInBits_t((__Reply__queryKeySizeInBits_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__queryKeySizeInBits_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*length = Out0P->length;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__getOutputSize_t__defined)
#define __MIG_check__Reply__getOutputSize_t__defined

mig_internal kern_return_t __MIG_check__Reply__getOutputSize_t(__Reply__getOutputSize_t *Out0P)
{

	typedef __Reply__getOutputSize_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1132) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__getOutputSize_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine getOutputSize */
mig_external kern_return_t ucsp_client_getOutputSize
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle key,
	uint32 inputSize,
	boolean_t encrypt,
	uint32 *outputSize
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		uint32 inputSize;
		boolean_t encrypt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		uint32 outputSize;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		uint32 outputSize;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__getOutputSize_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__getOutputSize_t__defined */

	__DeclareSendRpc(1032, "getOutputSize")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t contextTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->context = contextTemplate;
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
#else	/* UseStaticTemplates */
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
	InP->context.deallocate =  FALSE;
	InP->context.copy = MACH_MSG_VIRTUAL_COPY;
	InP->context.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->contextCnt = contextCnt;

	InP->key = key;

	InP->inputSize = inputSize;

	InP->encrypt = encrypt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1032;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1032, "getOutputSize")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1032, "getOutputSize")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__getOutputSize_t__defined)
	check_result = __MIG_check__Reply__getOutputSize_t((__Reply__getOutputSize_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__getOutputSize_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*outputSize = Out0P->outputSize;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__getKeyDigest_t__defined)
#define __MIG_check__Reply__getKeyDigest_t__defined

mig_internal kern_return_t __MIG_check__Reply__getKeyDigest_t(__Reply__getKeyDigest_t *Out0P)
{

	typedef __Reply__getKeyDigest_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1133) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->digest.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->digest.size != Out0P->digestCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__getKeyDigest_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine getKeyDigest */
mig_external kern_return_t ucsp_client_getKeyDigest
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCKeyHandle key,
	Data *digest,
	mach_msg_type_number_t *digestCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCKeyHandle key;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t digest;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t digestCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t digest;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t digestCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__getKeyDigest_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__getKeyDigest_t__defined */

	__DeclareSendRpc(1033, "getKeyDigest")

	InP->NDR = NDR_record;

	InP->key = key;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1033;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1033, "getKeyDigest")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1033, "getKeyDigest")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__getKeyDigest_t__defined)
	check_result = __MIG_check__Reply__getKeyDigest_t((__Reply__getKeyDigest_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__getKeyDigest_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*digest = (Data)(Out0P->digest.address);
	*digestCnt = Out0P->digestCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__generateSignature_t__defined)
#define __MIG_check__Reply__generateSignature_t__defined

mig_internal kern_return_t __MIG_check__Reply__generateSignature_t(__Reply__generateSignature_t *Out0P)
{

	typedef __Reply__generateSignature_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1134) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->signature.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->signature.size != Out0P->signatureCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__generateSignature_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine generateSignature */
mig_external kern_return_t ucsp_client_generateSignature
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle key,
	CSSM_ALGORITHMS signOnlyAlgorithm,
	Data data,
	mach_msg_type_number_t dataCnt,
	Data *signature,
	mach_msg_type_number_t *signatureCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		CSSM_ALGORITHMS signOnlyAlgorithm;
		mach_msg_type_number_t dataCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t signature;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t signatureCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t signature;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t signatureCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__generateSignature_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__generateSignature_t__defined */

	__DeclareSendRpc(1034, "generateSignature")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t contextTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t dataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 2;
#if	UseStaticTemplates
	InP->context = contextTemplate;
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
#else	/* UseStaticTemplates */
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
	InP->context.deallocate =  FALSE;
	InP->context.copy = MACH_MSG_VIRTUAL_COPY;
	InP->context.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->data = dataTemplate;
	InP->data.address = (void *)(data);
	InP->data.size = dataCnt;
#else	/* UseStaticTemplates */
	InP->data.address = (void *)(data);
	InP->data.size = dataCnt;
	InP->data.deallocate =  FALSE;
	InP->data.copy = MACH_MSG_VIRTUAL_COPY;
	InP->data.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->contextCnt = contextCnt;

	InP->key = key;

	InP->signOnlyAlgorithm = signOnlyAlgorithm;

	InP->dataCnt = dataCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1034;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1034, "generateSignature")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1034, "generateSignature")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__generateSignature_t__defined)
	check_result = __MIG_check__Reply__generateSignature_t((__Reply__generateSignature_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__generateSignature_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*signature = (Data)(Out0P->signature.address);
	*signatureCnt = Out0P->signatureCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__verifySignature_t__defined)
#define __MIG_check__Reply__verifySignature_t__defined

mig_internal kern_return_t __MIG_check__Reply__verifySignature_t(__Reply__verifySignature_t *Out0P)
{

	typedef __Reply__verifySignature_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1135) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__verifySignature_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine verifySignature */
mig_external kern_return_t ucsp_client_verifySignature
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle key,
	CSSM_ALGORITHMS signOnlyAlgorithm,
	Data data,
	mach_msg_type_number_t dataCnt,
	Data signature,
	mach_msg_type_number_t signatureCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t data;
		mach_msg_ool_descriptor_t signature;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		CSSM_ALGORITHMS signOnlyAlgorithm;
		mach_msg_type_number_t dataCnt;
		mach_msg_type_number_t signatureCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__verifySignature_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__verifySignature_t__defined */

	__DeclareSendRpc(1035, "verifySignature")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t contextTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t dataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t signatureTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 3;
#if	UseStaticTemplates
	InP->context = contextTemplate;
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
#else	/* UseStaticTemplates */
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
	InP->context.deallocate =  FALSE;
	InP->context.copy = MACH_MSG_VIRTUAL_COPY;
	InP->context.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->data = dataTemplate;
	InP->data.address = (void *)(data);
	InP->data.size = dataCnt;
#else	/* UseStaticTemplates */
	InP->data.address = (void *)(data);
	InP->data.size = dataCnt;
	InP->data.deallocate =  FALSE;
	InP->data.copy = MACH_MSG_VIRTUAL_COPY;
	InP->data.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->signature = signatureTemplate;
	InP->signature.address = (void *)(signature);
	InP->signature.size = signatureCnt;
#else	/* UseStaticTemplates */
	InP->signature.address = (void *)(signature);
	InP->signature.size = signatureCnt;
	InP->signature.deallocate =  FALSE;
	InP->signature.copy = MACH_MSG_VIRTUAL_COPY;
	InP->signature.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->contextCnt = contextCnt;

	InP->key = key;

	InP->signOnlyAlgorithm = signOnlyAlgorithm;

	InP->dataCnt = dataCnt;

	InP->signatureCnt = signatureCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1035;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1035, "verifySignature")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1035, "verifySignature")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__verifySignature_t__defined)
	check_result = __MIG_check__Reply__verifySignature_t((__Reply__verifySignature_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__verifySignature_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__generateMac_t__defined)
#define __MIG_check__Reply__generateMac_t__defined

mig_internal kern_return_t __MIG_check__Reply__generateMac_t(__Reply__generateMac_t *Out0P)
{

	typedef __Reply__generateMac_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1136) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->signature.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->signature.size != Out0P->signatureCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__generateMac_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine generateMac */
mig_external kern_return_t ucsp_client_generateMac
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle key,
	Data data,
	mach_msg_type_number_t dataCnt,
	Data *signature,
	mach_msg_type_number_t *signatureCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t dataCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t signature;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t signatureCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t signature;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t signatureCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__generateMac_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__generateMac_t__defined */

	__DeclareSendRpc(1036, "generateMac")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t contextTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t dataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 2;
#if	UseStaticTemplates
	InP->context = contextTemplate;
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
#else	/* UseStaticTemplates */
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
	InP->context.deallocate =  FALSE;
	InP->context.copy = MACH_MSG_VIRTUAL_COPY;
	InP->context.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->data = dataTemplate;
	InP->data.address = (void *)(data);
	InP->data.size = dataCnt;
#else	/* UseStaticTemplates */
	InP->data.address = (void *)(data);
	InP->data.size = dataCnt;
	InP->data.deallocate =  FALSE;
	InP->data.copy = MACH_MSG_VIRTUAL_COPY;
	InP->data.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->contextCnt = contextCnt;

	InP->key = key;

	InP->dataCnt = dataCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1036;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1036, "generateMac")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1036, "generateMac")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__generateMac_t__defined)
	check_result = __MIG_check__Reply__generateMac_t((__Reply__generateMac_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__generateMac_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*signature = (Data)(Out0P->signature.address);
	*signatureCnt = Out0P->signatureCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__verifyMac_t__defined)
#define __MIG_check__Reply__verifyMac_t__defined

mig_internal kern_return_t __MIG_check__Reply__verifyMac_t(__Reply__verifyMac_t *Out0P)
{

	typedef __Reply__verifyMac_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1137) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__verifyMac_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine verifyMac */
mig_external kern_return_t ucsp_client_verifyMac
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle key,
	Data data,
	mach_msg_type_number_t dataCnt,
	Data signature,
	mach_msg_type_number_t signatureCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t data;
		mach_msg_ool_descriptor_t signature;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t dataCnt;
		mach_msg_type_number_t signatureCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__verifyMac_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__verifyMac_t__defined */

	__DeclareSendRpc(1037, "verifyMac")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t contextTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t dataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t signatureTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 3;
#if	UseStaticTemplates
	InP->context = contextTemplate;
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
#else	/* UseStaticTemplates */
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
	InP->context.deallocate =  FALSE;
	InP->context.copy = MACH_MSG_VIRTUAL_COPY;
	InP->context.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->data = dataTemplate;
	InP->data.address = (void *)(data);
	InP->data.size = dataCnt;
#else	/* UseStaticTemplates */
	InP->data.address = (void *)(data);
	InP->data.size = dataCnt;
	InP->data.deallocate =  FALSE;
	InP->data.copy = MACH_MSG_VIRTUAL_COPY;
	InP->data.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->signature = signatureTemplate;
	InP->signature.address = (void *)(signature);
	InP->signature.size = signatureCnt;
#else	/* UseStaticTemplates */
	InP->signature.address = (void *)(signature);
	InP->signature.size = signatureCnt;
	InP->signature.deallocate =  FALSE;
	InP->signature.copy = MACH_MSG_VIRTUAL_COPY;
	InP->signature.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->contextCnt = contextCnt;

	InP->key = key;

	InP->dataCnt = dataCnt;

	InP->signatureCnt = signatureCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1037;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1037, "verifyMac")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1037, "verifyMac")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__verifyMac_t__defined)
	check_result = __MIG_check__Reply__verifyMac_t((__Reply__verifyMac_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__verifyMac_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__encrypt_t__defined)
#define __MIG_check__Reply__encrypt_t__defined

mig_internal kern_return_t __MIG_check__Reply__encrypt_t(__Reply__encrypt_t *Out0P)
{

	typedef __Reply__encrypt_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1138) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->cipher.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->cipher.size != Out0P->cipherCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__encrypt_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine encrypt */
mig_external kern_return_t ucsp_client_encrypt
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle key,
	Data clear,
	mach_msg_type_number_t clearCnt,
	Data *cipher,
	mach_msg_type_number_t *cipherCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t clear;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t clearCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t cipher;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t cipherCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t cipher;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t cipherCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__encrypt_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__encrypt_t__defined */

	__DeclareSendRpc(1038, "encrypt")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t contextTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t clearTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 2;
#if	UseStaticTemplates
	InP->context = contextTemplate;
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
#else	/* UseStaticTemplates */
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
	InP->context.deallocate =  FALSE;
	InP->context.copy = MACH_MSG_VIRTUAL_COPY;
	InP->context.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->clear = clearTemplate;
	InP->clear.address = (void *)(clear);
	InP->clear.size = clearCnt;
#else	/* UseStaticTemplates */
	InP->clear.address = (void *)(clear);
	InP->clear.size = clearCnt;
	InP->clear.deallocate =  FALSE;
	InP->clear.copy = MACH_MSG_VIRTUAL_COPY;
	InP->clear.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->contextCnt = contextCnt;

	InP->key = key;

	InP->clearCnt = clearCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1038;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1038, "encrypt")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1038, "encrypt")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__encrypt_t__defined)
	check_result = __MIG_check__Reply__encrypt_t((__Reply__encrypt_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__encrypt_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*cipher = (Data)(Out0P->cipher.address);
	*cipherCnt = Out0P->cipherCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__decrypt_t__defined)
#define __MIG_check__Reply__decrypt_t__defined

mig_internal kern_return_t __MIG_check__Reply__decrypt_t(__Reply__decrypt_t *Out0P)
{

	typedef __Reply__decrypt_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1139) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->clear.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->clear.size != Out0P->clearCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__decrypt_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine decrypt */
mig_external kern_return_t ucsp_client_decrypt
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle key,
	Data cipher,
	mach_msg_type_number_t cipherCnt,
	Data *clear,
	mach_msg_type_number_t *clearCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t cipher;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t cipherCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t clear;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t clearCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t clear;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t clearCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__decrypt_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__decrypt_t__defined */

	__DeclareSendRpc(1039, "decrypt")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t contextTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t cipherTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 2;
#if	UseStaticTemplates
	InP->context = contextTemplate;
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
#else	/* UseStaticTemplates */
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
	InP->context.deallocate =  FALSE;
	InP->context.copy = MACH_MSG_VIRTUAL_COPY;
	InP->context.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->cipher = cipherTemplate;
	InP->cipher.address = (void *)(cipher);
	InP->cipher.size = cipherCnt;
#else	/* UseStaticTemplates */
	InP->cipher.address = (void *)(cipher);
	InP->cipher.size = cipherCnt;
	InP->cipher.deallocate =  FALSE;
	InP->cipher.copy = MACH_MSG_VIRTUAL_COPY;
	InP->cipher.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->contextCnt = contextCnt;

	InP->key = key;

	InP->cipherCnt = cipherCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1039;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1039, "decrypt")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1039, "decrypt")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__decrypt_t__defined)
	check_result = __MIG_check__Reply__decrypt_t((__Reply__decrypt_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__decrypt_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*clear = (Data)(Out0P->clear.address);
	*clearCnt = Out0P->clearCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__generateKey_t__defined)
#define __MIG_check__Reply__generateKey_t__defined

mig_internal kern_return_t __MIG_check__Reply__generateKey_t(__Reply__generateKey_t *Out0P)
{

	typedef __Reply__generateKey_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1140) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->header.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->header.size != Out0P->headerCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__generateKey_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine generateKey */
mig_external kern_return_t ucsp_client_generateKey
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	Data context,
	mach_msg_type_number_t contextCnt,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	Data aclEntryPrototype,
	mach_msg_type_number_t aclEntryPrototypeCnt,
	uint32 keyUsage,
	uint32 keyAttrs,
	IPCKeyHandle *key,
	Data *header,
	mach_msg_type_number_t *headerCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryPrototype;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t contextCnt;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclEntryPrototypeCnt;
		uint32 keyUsage;
		uint32 keyAttrs;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t header;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		IPCKeyHandle key;
		mach_msg_type_number_t headerCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t header;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		IPCKeyHandle key;
		mach_msg_type_number_t headerCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__generateKey_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__generateKey_t__defined */

	__DeclareSendRpc(1040, "generateKey")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t contextTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t accessCredentialsTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t aclEntryPrototypeTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 3;
#if	UseStaticTemplates
	InP->context = contextTemplate;
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
#else	/* UseStaticTemplates */
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
	InP->context.deallocate =  FALSE;
	InP->context.copy = MACH_MSG_VIRTUAL_COPY;
	InP->context.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->accessCredentials = accessCredentialsTemplate;
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
#else	/* UseStaticTemplates */
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
	InP->accessCredentials.deallocate =  FALSE;
	InP->accessCredentials.copy = MACH_MSG_VIRTUAL_COPY;
	InP->accessCredentials.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->aclEntryPrototype = aclEntryPrototypeTemplate;
	InP->aclEntryPrototype.address = (void *)(aclEntryPrototype);
	InP->aclEntryPrototype.size = aclEntryPrototypeCnt;
#else	/* UseStaticTemplates */
	InP->aclEntryPrototype.address = (void *)(aclEntryPrototype);
	InP->aclEntryPrototype.size = aclEntryPrototypeCnt;
	InP->aclEntryPrototype.deallocate =  FALSE;
	InP->aclEntryPrototype.copy = MACH_MSG_VIRTUAL_COPY;
	InP->aclEntryPrototype.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->db = db;

	InP->contextCnt = contextCnt;

	InP->accessCredentialsCnt = accessCredentialsCnt;

	InP->aclEntryPrototypeCnt = aclEntryPrototypeCnt;

	InP->keyUsage = keyUsage;

	InP->keyAttrs = keyAttrs;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1040;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1040, "generateKey")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1040, "generateKey")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__generateKey_t__defined)
	check_result = __MIG_check__Reply__generateKey_t((__Reply__generateKey_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__generateKey_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*key = Out0P->key;

	*header = (Data)(Out0P->header.address);
	*headerCnt = Out0P->headerCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__generateKeyPair_t__defined)
#define __MIG_check__Reply__generateKeyPair_t__defined

mig_internal kern_return_t __MIG_check__Reply__generateKeyPair_t(__Reply__generateKeyPair_t *Out0P)
{

	typedef __Reply__generateKeyPair_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1141) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 2 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->pubHeader.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->privHeader.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->pubHeader.size != Out0P->pubHeaderCnt)
		return MIG_TYPE_ERROR;
	if (Out0P->privHeader.size != Out0P->privHeaderCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__generateKeyPair_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine generateKeyPair */
mig_external kern_return_t ucsp_client_generateKeyPair
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	Data context,
	mach_msg_type_number_t contextCnt,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	Data aclEntryPrototype,
	mach_msg_type_number_t aclEntryPrototypeCnt,
	uint32 pubUsage,
	uint32 pubAttrs,
	uint32 privUsage,
	uint32 privAttrs,
	IPCKeyHandle *pubKey,
	Data *pubHeader,
	mach_msg_type_number_t *pubHeaderCnt,
	IPCKeyHandle *privKey,
	Data *privHeader,
	mach_msg_type_number_t *privHeaderCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryPrototype;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t contextCnt;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclEntryPrototypeCnt;
		uint32 pubUsage;
		uint32 pubAttrs;
		uint32 privUsage;
		uint32 privAttrs;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t pubHeader;
		mach_msg_ool_descriptor_t privHeader;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		IPCKeyHandle pubKey;
		mach_msg_type_number_t pubHeaderCnt;
		IPCKeyHandle privKey;
		mach_msg_type_number_t privHeaderCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t pubHeader;
		mach_msg_ool_descriptor_t privHeader;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		IPCKeyHandle pubKey;
		mach_msg_type_number_t pubHeaderCnt;
		IPCKeyHandle privKey;
		mach_msg_type_number_t privHeaderCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__generateKeyPair_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__generateKeyPair_t__defined */

	__DeclareSendRpc(1041, "generateKeyPair")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t contextTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t accessCredentialsTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t aclEntryPrototypeTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 3;
#if	UseStaticTemplates
	InP->context = contextTemplate;
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
#else	/* UseStaticTemplates */
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
	InP->context.deallocate =  FALSE;
	InP->context.copy = MACH_MSG_VIRTUAL_COPY;
	InP->context.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->accessCredentials = accessCredentialsTemplate;
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
#else	/* UseStaticTemplates */
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
	InP->accessCredentials.deallocate =  FALSE;
	InP->accessCredentials.copy = MACH_MSG_VIRTUAL_COPY;
	InP->accessCredentials.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->aclEntryPrototype = aclEntryPrototypeTemplate;
	InP->aclEntryPrototype.address = (void *)(aclEntryPrototype);
	InP->aclEntryPrototype.size = aclEntryPrototypeCnt;
#else	/* UseStaticTemplates */
	InP->aclEntryPrototype.address = (void *)(aclEntryPrototype);
	InP->aclEntryPrototype.size = aclEntryPrototypeCnt;
	InP->aclEntryPrototype.deallocate =  FALSE;
	InP->aclEntryPrototype.copy = MACH_MSG_VIRTUAL_COPY;
	InP->aclEntryPrototype.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->db = db;

	InP->contextCnt = contextCnt;

	InP->accessCredentialsCnt = accessCredentialsCnt;

	InP->aclEntryPrototypeCnt = aclEntryPrototypeCnt;

	InP->pubUsage = pubUsage;

	InP->pubAttrs = pubAttrs;

	InP->privUsage = privUsage;

	InP->privAttrs = privAttrs;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1041;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1041, "generateKeyPair")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1041, "generateKeyPair")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__generateKeyPair_t__defined)
	check_result = __MIG_check__Reply__generateKeyPair_t((__Reply__generateKeyPair_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__generateKeyPair_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*pubKey = Out0P->pubKey;

	*pubHeader = (Data)(Out0P->pubHeader.address);
	*pubHeaderCnt = Out0P->pubHeaderCnt;

	*privKey = Out0P->privKey;

	*privHeader = (Data)(Out0P->privHeader.address);
	*privHeaderCnt = Out0P->privHeaderCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__wrapKey_t__defined)
#define __MIG_check__Reply__wrapKey_t__defined

mig_internal kern_return_t __MIG_check__Reply__wrapKey_t(__Reply__wrapKey_t *Out0P)
{

	typedef __Reply__wrapKey_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1142) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->wrappedKey.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->wrappedKey.size != Out0P->wrappedKeyCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__wrapKey_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine wrapKey */
mig_external kern_return_t ucsp_client_wrapKey
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle key,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	IPCKeyHandle keyToBeWrapped,
	Data descriptiveData,
	mach_msg_type_number_t descriptiveDataCnt,
	Data *wrappedKey,
	mach_msg_type_number_t *wrappedKeyCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t descriptiveData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t accessCredentialsCnt;
		IPCKeyHandle keyToBeWrapped;
		mach_msg_type_number_t descriptiveDataCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t wrappedKey;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t wrappedKeyCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t wrappedKey;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t wrappedKeyCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__wrapKey_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__wrapKey_t__defined */

	__DeclareSendRpc(1042, "wrapKey")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t contextTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t accessCredentialsTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t descriptiveDataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 3;
#if	UseStaticTemplates
	InP->context = contextTemplate;
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
#else	/* UseStaticTemplates */
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
	InP->context.deallocate =  FALSE;
	InP->context.copy = MACH_MSG_VIRTUAL_COPY;
	InP->context.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->accessCredentials = accessCredentialsTemplate;
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
#else	/* UseStaticTemplates */
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
	InP->accessCredentials.deallocate =  FALSE;
	InP->accessCredentials.copy = MACH_MSG_VIRTUAL_COPY;
	InP->accessCredentials.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->descriptiveData = descriptiveDataTemplate;
	InP->descriptiveData.address = (void *)(descriptiveData);
	InP->descriptiveData.size = descriptiveDataCnt;
#else	/* UseStaticTemplates */
	InP->descriptiveData.address = (void *)(descriptiveData);
	InP->descriptiveData.size = descriptiveDataCnt;
	InP->descriptiveData.deallocate =  FALSE;
	InP->descriptiveData.copy = MACH_MSG_VIRTUAL_COPY;
	InP->descriptiveData.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->contextCnt = contextCnt;

	InP->key = key;

	InP->accessCredentialsCnt = accessCredentialsCnt;

	InP->keyToBeWrapped = keyToBeWrapped;

	InP->descriptiveDataCnt = descriptiveDataCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1042;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1042, "wrapKey")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1042, "wrapKey")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__wrapKey_t__defined)
	check_result = __MIG_check__Reply__wrapKey_t((__Reply__wrapKey_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__wrapKey_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*wrappedKey = (Data)(Out0P->wrappedKey.address);
	*wrappedKeyCnt = Out0P->wrappedKeyCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__unwrapKey_t__defined)
#define __MIG_check__Reply__unwrapKey_t__defined

mig_internal kern_return_t __MIG_check__Reply__unwrapKey_t(__Reply__unwrapKey_t *Out0P)
{

	typedef __Reply__unwrapKey_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1143) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 2 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->data.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->header.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->data.size != Out0P->dataCnt)
		return MIG_TYPE_ERROR;
	if (Out0P->header.size != Out0P->headerCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__unwrapKey_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine unwrapKey */
mig_external kern_return_t ucsp_client_unwrapKey
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle key,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	Data aclEntryPrototype,
	mach_msg_type_number_t aclEntryPrototypeCnt,
	IPCKeyHandle publicKey,
	Data wrappedKey,
	mach_msg_type_number_t wrappedKeyCnt,
	uint32 usage,
	uint32 attributes,
	Data *data,
	mach_msg_type_number_t *dataCnt,
	IPCKeyHandle *resultKey,
	Data *header,
	mach_msg_type_number_t *headerCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryPrototype;
		mach_msg_ool_descriptor_t wrappedKey;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclEntryPrototypeCnt;
		IPCKeyHandle publicKey;
		mach_msg_type_number_t wrappedKeyCnt;
		uint32 usage;
		uint32 attributes;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t data;
		mach_msg_ool_descriptor_t header;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t dataCnt;
		IPCKeyHandle resultKey;
		mach_msg_type_number_t headerCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t data;
		mach_msg_ool_descriptor_t header;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t dataCnt;
		IPCKeyHandle resultKey;
		mach_msg_type_number_t headerCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__unwrapKey_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__unwrapKey_t__defined */

	__DeclareSendRpc(1043, "unwrapKey")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t contextTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t accessCredentialsTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t aclEntryPrototypeTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t wrappedKeyTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 4;
#if	UseStaticTemplates
	InP->context = contextTemplate;
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
#else	/* UseStaticTemplates */
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
	InP->context.deallocate =  FALSE;
	InP->context.copy = MACH_MSG_VIRTUAL_COPY;
	InP->context.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->accessCredentials = accessCredentialsTemplate;
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
#else	/* UseStaticTemplates */
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
	InP->accessCredentials.deallocate =  FALSE;
	InP->accessCredentials.copy = MACH_MSG_VIRTUAL_COPY;
	InP->accessCredentials.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->aclEntryPrototype = aclEntryPrototypeTemplate;
	InP->aclEntryPrototype.address = (void *)(aclEntryPrototype);
	InP->aclEntryPrototype.size = aclEntryPrototypeCnt;
#else	/* UseStaticTemplates */
	InP->aclEntryPrototype.address = (void *)(aclEntryPrototype);
	InP->aclEntryPrototype.size = aclEntryPrototypeCnt;
	InP->aclEntryPrototype.deallocate =  FALSE;
	InP->aclEntryPrototype.copy = MACH_MSG_VIRTUAL_COPY;
	InP->aclEntryPrototype.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->wrappedKey = wrappedKeyTemplate;
	InP->wrappedKey.address = (void *)(wrappedKey);
	InP->wrappedKey.size = wrappedKeyCnt;
#else	/* UseStaticTemplates */
	InP->wrappedKey.address = (void *)(wrappedKey);
	InP->wrappedKey.size = wrappedKeyCnt;
	InP->wrappedKey.deallocate =  FALSE;
	InP->wrappedKey.copy = MACH_MSG_VIRTUAL_COPY;
	InP->wrappedKey.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->db = db;

	InP->contextCnt = contextCnt;

	InP->key = key;

	InP->accessCredentialsCnt = accessCredentialsCnt;

	InP->aclEntryPrototypeCnt = aclEntryPrototypeCnt;

	InP->publicKey = publicKey;

	InP->wrappedKeyCnt = wrappedKeyCnt;

	InP->usage = usage;

	InP->attributes = attributes;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1043;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1043, "unwrapKey")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1043, "unwrapKey")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__unwrapKey_t__defined)
	check_result = __MIG_check__Reply__unwrapKey_t((__Reply__unwrapKey_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__unwrapKey_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*data = (Data)(Out0P->data.address);
	*dataCnt = Out0P->dataCnt;

	*resultKey = Out0P->resultKey;

	*header = (Data)(Out0P->header.address);
	*headerCnt = Out0P->headerCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__deriveKey_t__defined)
#define __MIG_check__Reply__deriveKey_t__defined

mig_internal kern_return_t __MIG_check__Reply__deriveKey_t(__Reply__deriveKey_t *Out0P)
{

	typedef __Reply__deriveKey_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1144) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 2 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->paramOutput.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (Out0P->header.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->paramOutput.size != Out0P->paramOutputCnt)
		return MIG_TYPE_ERROR;
	if (Out0P->header.size != Out0P->headerCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__deriveKey_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine deriveKey */
mig_external kern_return_t ucsp_client_deriveKey
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle baseKey,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	Data aclEntryPrototype,
	mach_msg_type_number_t aclEntryPrototypeCnt,
	Data paramInput,
	mach_msg_type_number_t paramInputCnt,
	Data *paramOutput,
	mach_msg_type_number_t *paramOutputCnt,
	uint32 keyUsage,
	uint32 keyAttrs,
	IPCKeyHandle *key,
	Data *header,
	mach_msg_type_number_t *headerCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryPrototype;
		mach_msg_ool_descriptor_t paramInput;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle baseKey;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclEntryPrototypeCnt;
		mach_msg_type_number_t paramInputCnt;
		uint32 keyUsage;
		uint32 keyAttrs;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t paramOutput;
		mach_msg_ool_descriptor_t header;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t paramOutputCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t headerCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t paramOutput;
		mach_msg_ool_descriptor_t header;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t paramOutputCnt;
		IPCKeyHandle key;
		mach_msg_type_number_t headerCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__deriveKey_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__deriveKey_t__defined */

	__DeclareSendRpc(1044, "deriveKey")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t contextTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t accessCredentialsTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t aclEntryPrototypeTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t paramInputTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 4;
#if	UseStaticTemplates
	InP->context = contextTemplate;
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
#else	/* UseStaticTemplates */
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
	InP->context.deallocate =  FALSE;
	InP->context.copy = MACH_MSG_VIRTUAL_COPY;
	InP->context.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->accessCredentials = accessCredentialsTemplate;
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
#else	/* UseStaticTemplates */
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
	InP->accessCredentials.deallocate =  FALSE;
	InP->accessCredentials.copy = MACH_MSG_VIRTUAL_COPY;
	InP->accessCredentials.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->aclEntryPrototype = aclEntryPrototypeTemplate;
	InP->aclEntryPrototype.address = (void *)(aclEntryPrototype);
	InP->aclEntryPrototype.size = aclEntryPrototypeCnt;
#else	/* UseStaticTemplates */
	InP->aclEntryPrototype.address = (void *)(aclEntryPrototype);
	InP->aclEntryPrototype.size = aclEntryPrototypeCnt;
	InP->aclEntryPrototype.deallocate =  FALSE;
	InP->aclEntryPrototype.copy = MACH_MSG_VIRTUAL_COPY;
	InP->aclEntryPrototype.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->paramInput = paramInputTemplate;
	InP->paramInput.address = (void *)(paramInput);
	InP->paramInput.size = paramInputCnt;
#else	/* UseStaticTemplates */
	InP->paramInput.address = (void *)(paramInput);
	InP->paramInput.size = paramInputCnt;
	InP->paramInput.deallocate =  FALSE;
	InP->paramInput.copy = MACH_MSG_VIRTUAL_COPY;
	InP->paramInput.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->db = db;

	InP->contextCnt = contextCnt;

	InP->baseKey = baseKey;

	InP->accessCredentialsCnt = accessCredentialsCnt;

	InP->aclEntryPrototypeCnt = aclEntryPrototypeCnt;

	InP->paramInputCnt = paramInputCnt;

	InP->keyUsage = keyUsage;

	InP->keyAttrs = keyAttrs;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1044;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1044, "deriveKey")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1044, "deriveKey")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__deriveKey_t__defined)
	check_result = __MIG_check__Reply__deriveKey_t((__Reply__deriveKey_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__deriveKey_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*paramOutput = (Data)(Out0P->paramOutput.address);
	*paramOutputCnt = Out0P->paramOutputCnt;

	*key = Out0P->key;

	*header = (Data)(Out0P->header.address);
	*headerCnt = Out0P->headerCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__generateRandom_t__defined)
#define __MIG_check__Reply__generateRandom_t__defined

mig_internal kern_return_t __MIG_check__Reply__generateRandom_t(__Reply__generateRandom_t *Out0P)
{

	typedef __Reply__generateRandom_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1145) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->data.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->data.size != Out0P->dataCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__generateRandom_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine generateRandom */
mig_external kern_return_t ucsp_client_generateRandom
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	uint32 ssid,
	Data context,
	mach_msg_type_number_t contextCnt,
	Data *data,
	mach_msg_type_number_t *dataCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32 ssid;
		mach_msg_type_number_t contextCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t dataCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t dataCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__generateRandom_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__generateRandom_t__defined */

	__DeclareSendRpc(1045, "generateRandom")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t contextTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->context = contextTemplate;
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
#else	/* UseStaticTemplates */
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
	InP->context.deallocate =  FALSE;
	InP->context.copy = MACH_MSG_VIRTUAL_COPY;
	InP->context.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->ssid = ssid;

	InP->contextCnt = contextCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1045;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1045, "generateRandom")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1045, "generateRandom")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__generateRandom_t__defined)
	check_result = __MIG_check__Reply__generateRandom_t((__Reply__generateRandom_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__generateRandom_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*data = (Data)(Out0P->data.address);
	*dataCnt = Out0P->dataCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__getOwner_t__defined)
#define __MIG_check__Reply__getOwner_t__defined

mig_internal kern_return_t __MIG_check__Reply__getOwner_t(__Reply__getOwner_t *Out0P)
{

	typedef __Reply__getOwner_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1146) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->proto.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->proto.size != Out0P->protoCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__getOwner_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine getOwner */
mig_external kern_return_t ucsp_client_getOwner
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	AclKind kind,
	IPCGenericHandle key,
	Data *proto,
	mach_msg_type_number_t *protoCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		AclKind kind;
		IPCGenericHandle key;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t proto;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t protoCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t proto;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t protoCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__getOwner_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__getOwner_t__defined */

	__DeclareSendRpc(1046, "getOwner")

	InP->NDR = NDR_record;

	InP->kind = kind;

	InP->key = key;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1046;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1046, "getOwner")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1046, "getOwner")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__getOwner_t__defined)
	check_result = __MIG_check__Reply__getOwner_t((__Reply__getOwner_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__getOwner_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*proto = (Data)(Out0P->proto.address);
	*protoCnt = Out0P->protoCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__setOwner_t__defined)
#define __MIG_check__Reply__setOwner_t__defined

mig_internal kern_return_t __MIG_check__Reply__setOwner_t(__Reply__setOwner_t *Out0P)
{

	typedef __Reply__setOwner_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1147) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__setOwner_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine setOwner */
mig_external kern_return_t ucsp_client_setOwner
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	AclKind kind,
	IPCGenericHandle key,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	Data aclOwnerPrototype,
	mach_msg_type_number_t aclOwnerPrototypeCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclOwnerPrototype;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		AclKind kind;
		IPCGenericHandle key;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclOwnerPrototypeCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__setOwner_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__setOwner_t__defined */

	__DeclareSendRpc(1047, "setOwner")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t accessCredentialsTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t aclOwnerPrototypeTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 2;
#if	UseStaticTemplates
	InP->accessCredentials = accessCredentialsTemplate;
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
#else	/* UseStaticTemplates */
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
	InP->accessCredentials.deallocate =  FALSE;
	InP->accessCredentials.copy = MACH_MSG_VIRTUAL_COPY;
	InP->accessCredentials.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->aclOwnerPrototype = aclOwnerPrototypeTemplate;
	InP->aclOwnerPrototype.address = (void *)(aclOwnerPrototype);
	InP->aclOwnerPrototype.size = aclOwnerPrototypeCnt;
#else	/* UseStaticTemplates */
	InP->aclOwnerPrototype.address = (void *)(aclOwnerPrototype);
	InP->aclOwnerPrototype.size = aclOwnerPrototypeCnt;
	InP->aclOwnerPrototype.deallocate =  FALSE;
	InP->aclOwnerPrototype.copy = MACH_MSG_VIRTUAL_COPY;
	InP->aclOwnerPrototype.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->kind = kind;

	InP->key = key;

	InP->accessCredentialsCnt = accessCredentialsCnt;

	InP->aclOwnerPrototypeCnt = aclOwnerPrototypeCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1047;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1047, "setOwner")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1047, "setOwner")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__setOwner_t__defined)
	check_result = __MIG_check__Reply__setOwner_t((__Reply__setOwner_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__setOwner_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__getAcl_t__defined)
#define __MIG_check__Reply__getAcl_t__defined

mig_internal kern_return_t __MIG_check__Reply__getAcl_t(__Reply__getAcl_t *Out0P)
{

	typedef __Reply__getAcl_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1148) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->acls.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->acls.size != Out0P->aclsCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__getAcl_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine getAcl */
mig_external kern_return_t ucsp_client_getAcl
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	AclKind kind,
	IPCGenericHandle key,
	boolean_t haveTag,
	CssmString tag,
	uint32 *count,
	Data *acls,
	mach_msg_type_number_t *aclsCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		AclKind kind;
		IPCGenericHandle key;
		boolean_t haveTag;
		mach_msg_type_number_t tagOffset; /* MiG doesn't use it */
		mach_msg_type_number_t tagCnt;
		char tag[68];
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t acls;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		uint32 count;
		mach_msg_type_number_t aclsCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t acls;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		uint32 count;
		mach_msg_type_number_t aclsCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__getAcl_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__getAcl_t__defined */

	__DeclareSendRpc(1048, "getAcl")

	InP->NDR = NDR_record;

	InP->kind = kind;

	InP->key = key;

	InP->haveTag = haveTag;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->tagCnt = mig_strncpy_zerofill(InP->tag, tag, 68);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->tagCnt = mig_strncpy(InP->tag, tag, 68);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */

	msgh_size = (mach_msg_size_t)(sizeof(Request) - 68) + (_WALIGN_(InP->tagCnt));
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1048;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1048, "getAcl")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1048, "getAcl")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__getAcl_t__defined)
	check_result = __MIG_check__Reply__getAcl_t((__Reply__getAcl_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__getAcl_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*count = Out0P->count;

	*acls = (Data)(Out0P->acls.address);
	*aclsCnt = Out0P->aclsCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__changeAcl_t__defined)
#define __MIG_check__Reply__changeAcl_t__defined

mig_internal kern_return_t __MIG_check__Reply__changeAcl_t(__Reply__changeAcl_t *Out0P)
{

	typedef __Reply__changeAcl_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1149) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__changeAcl_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine changeAcl */
mig_external kern_return_t ucsp_client_changeAcl
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	AclKind kind,
	IPCGenericHandle key,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	CSSM_ACL_EDIT_MODE mode,
	IPCGenericHandle handle,
	Data aclEntryInput,
	mach_msg_type_number_t aclEntryInputCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryInput;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		AclKind kind;
		IPCGenericHandle key;
		mach_msg_type_number_t accessCredentialsCnt;
		CSSM_ACL_EDIT_MODE mode;
		IPCGenericHandle handle;
		mach_msg_type_number_t aclEntryInputCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__changeAcl_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__changeAcl_t__defined */

	__DeclareSendRpc(1049, "changeAcl")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t accessCredentialsTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t aclEntryInputTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 2;
#if	UseStaticTemplates
	InP->accessCredentials = accessCredentialsTemplate;
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
#else	/* UseStaticTemplates */
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
	InP->accessCredentials.deallocate =  FALSE;
	InP->accessCredentials.copy = MACH_MSG_VIRTUAL_COPY;
	InP->accessCredentials.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->aclEntryInput = aclEntryInputTemplate;
	InP->aclEntryInput.address = (void *)(aclEntryInput);
	InP->aclEntryInput.size = aclEntryInputCnt;
#else	/* UseStaticTemplates */
	InP->aclEntryInput.address = (void *)(aclEntryInput);
	InP->aclEntryInput.size = aclEntryInputCnt;
	InP->aclEntryInput.deallocate =  FALSE;
	InP->aclEntryInput.copy = MACH_MSG_VIRTUAL_COPY;
	InP->aclEntryInput.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->kind = kind;

	InP->key = key;

	InP->accessCredentialsCnt = accessCredentialsCnt;

	InP->mode = mode;

	InP->handle = handle;

	InP->aclEntryInputCnt = aclEntryInputCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1049;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1049, "changeAcl")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1049, "changeAcl")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__changeAcl_t__defined)
	check_result = __MIG_check__Reply__changeAcl_t((__Reply__changeAcl_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__changeAcl_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__login_t__defined)
#define __MIG_check__Reply__login_t__defined

mig_internal kern_return_t __MIG_check__Reply__login_t(__Reply__login_t *Out0P)
{

	typedef __Reply__login_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1150) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__login_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine login */
mig_external kern_return_t ucsp_client_login
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	Data name,
	mach_msg_type_number_t nameCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t name;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t nameCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__login_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__login_t__defined */

	__DeclareSendRpc(1050, "login")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t accessCredentialsTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t nameTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 2;
#if	UseStaticTemplates
	InP->accessCredentials = accessCredentialsTemplate;
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
#else	/* UseStaticTemplates */
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
	InP->accessCredentials.deallocate =  FALSE;
	InP->accessCredentials.copy = MACH_MSG_VIRTUAL_COPY;
	InP->accessCredentials.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->name = nameTemplate;
	InP->name.address = (void *)(name);
	InP->name.size = nameCnt;
#else	/* UseStaticTemplates */
	InP->name.address = (void *)(name);
	InP->name.size = nameCnt;
	InP->name.deallocate =  FALSE;
	InP->name.copy = MACH_MSG_VIRTUAL_COPY;
	InP->name.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->accessCredentialsCnt = accessCredentialsCnt;

	InP->nameCnt = nameCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1050;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1050, "login")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1050, "login")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__login_t__defined)
	check_result = __MIG_check__Reply__login_t((__Reply__login_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__login_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__logout_t__defined)
#define __MIG_check__Reply__logout_t__defined

mig_internal kern_return_t __MIG_check__Reply__logout_t(__Reply__logout_t *Out0P)
{

	typedef __Reply__logout_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1151) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__logout_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine logout */
mig_external kern_return_t ucsp_client_logout
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__logout_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__logout_t__defined */

	__DeclareSendRpc(1051, "logout")

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1051;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1051, "logout")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1051, "logout")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__logout_t__defined)
	check_result = __MIG_check__Reply__logout_t((__Reply__logout_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__logout_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__getStatistics_t__defined)
#define __MIG_check__Reply__getStatistics_t__defined

mig_internal kern_return_t __MIG_check__Reply__getStatistics_t(__Reply__getStatistics_t *Out0P)
{

	typedef __Reply__getStatistics_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1152) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__getStatistics_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine getStatistics */
mig_external kern_return_t ucsp_client_getStatistics
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	uint32 ssid,
	CSSM_CSP_OPERATIONAL_STATISTICS *statistics
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32 ssid;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		CSSM_CSP_OPERATIONAL_STATISTICS statistics;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		CSSM_CSP_OPERATIONAL_STATISTICS statistics;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__getStatistics_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__getStatistics_t__defined */

	__DeclareSendRpc(1052, "getStatistics")

	InP->NDR = NDR_record;

	InP->ssid = ssid;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1052;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1052, "getStatistics")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1052, "getStatistics")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__getStatistics_t__defined)
	check_result = __MIG_check__Reply__getStatistics_t((__Reply__getStatistics_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__getStatistics_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*statistics = Out0P->statistics;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__getTime_t__defined)
#define __MIG_check__Reply__getTime_t__defined

mig_internal kern_return_t __MIG_check__Reply__getTime_t(__Reply__getTime_t *Out0P)
{

	typedef __Reply__getTime_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1153) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->data.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->data.size != Out0P->dataCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__getTime_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine getTime */
mig_external kern_return_t ucsp_client_getTime
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	uint32 ssid,
	CSSM_ALGORITHMS algorithm,
	Data *data,
	mach_msg_type_number_t *dataCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32 ssid;
		CSSM_ALGORITHMS algorithm;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t dataCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t dataCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__getTime_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__getTime_t__defined */

	__DeclareSendRpc(1053, "getTime")

	InP->NDR = NDR_record;

	InP->ssid = ssid;

	InP->algorithm = algorithm;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1053;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1053, "getTime")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1053, "getTime")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__getTime_t__defined)
	check_result = __MIG_check__Reply__getTime_t((__Reply__getTime_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__getTime_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*data = (Data)(Out0P->data.address);
	*dataCnt = Out0P->dataCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__getCounter_t__defined)
#define __MIG_check__Reply__getCounter_t__defined

mig_internal kern_return_t __MIG_check__Reply__getCounter_t(__Reply__getCounter_t *Out0P)
{

	typedef __Reply__getCounter_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1154) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->data.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->data.size != Out0P->dataCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__getCounter_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine getCounter */
mig_external kern_return_t ucsp_client_getCounter
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	uint32 ssid,
	Data *data,
	mach_msg_type_number_t *dataCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32 ssid;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t dataCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t dataCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__getCounter_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__getCounter_t__defined */

	__DeclareSendRpc(1054, "getCounter")

	InP->NDR = NDR_record;

	InP->ssid = ssid;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1054;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1054, "getCounter")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1054, "getCounter")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__getCounter_t__defined)
	check_result = __MIG_check__Reply__getCounter_t((__Reply__getCounter_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__getCounter_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*data = (Data)(Out0P->data.address);
	*dataCnt = Out0P->dataCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__selfVerify_t__defined)
#define __MIG_check__Reply__selfVerify_t__defined

mig_internal kern_return_t __MIG_check__Reply__selfVerify_t(__Reply__selfVerify_t *Out0P)
{

	typedef __Reply__selfVerify_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1155) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__selfVerify_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine selfVerify */
mig_external kern_return_t ucsp_client_selfVerify
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	uint32 ssid
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32 ssid;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__selfVerify_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__selfVerify_t__defined */

	__DeclareSendRpc(1055, "selfVerify")

	InP->NDR = NDR_record;

	InP->ssid = ssid;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1055;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1055, "selfVerify")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1055, "selfVerify")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__selfVerify_t__defined)
	check_result = __MIG_check__Reply__selfVerify_t((__Reply__selfVerify_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__selfVerify_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__cspPassThrough_t__defined)
#define __MIG_check__Reply__cspPassThrough_t__defined

mig_internal kern_return_t __MIG_check__Reply__cspPassThrough_t(__Reply__cspPassThrough_t *Out0P)
{

	typedef __Reply__cspPassThrough_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1156) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->outData.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->outData.size != Out0P->outDataCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__cspPassThrough_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine cspPassThrough */
mig_external kern_return_t ucsp_client_cspPassThrough
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	uint32 ssid,
	uint32 id,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCKeyHandle hKey,
	Data inData,
	mach_msg_type_number_t inDataCnt,
	Data *outData,
	mach_msg_type_number_t *outDataCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t inData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32 ssid;
		uint32 id;
		mach_msg_type_number_t contextCnt;
		IPCKeyHandle hKey;
		mach_msg_type_number_t inDataCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t outData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t outDataCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t outData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t outDataCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__cspPassThrough_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__cspPassThrough_t__defined */

	__DeclareSendRpc(1056, "cspPassThrough")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t contextTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t inDataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 2;
#if	UseStaticTemplates
	InP->context = contextTemplate;
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
#else	/* UseStaticTemplates */
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
	InP->context.deallocate =  FALSE;
	InP->context.copy = MACH_MSG_VIRTUAL_COPY;
	InP->context.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->inData = inDataTemplate;
	InP->inData.address = (void *)(inData);
	InP->inData.size = inDataCnt;
#else	/* UseStaticTemplates */
	InP->inData.address = (void *)(inData);
	InP->inData.size = inDataCnt;
	InP->inData.deallocate =  FALSE;
	InP->inData.copy = MACH_MSG_VIRTUAL_COPY;
	InP->inData.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->ssid = ssid;

	InP->id = id;

	InP->contextCnt = contextCnt;

	InP->hKey = hKey;

	InP->inDataCnt = inDataCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1056;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1056, "cspPassThrough")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1056, "cspPassThrough")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__cspPassThrough_t__defined)
	check_result = __MIG_check__Reply__cspPassThrough_t((__Reply__cspPassThrough_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__cspPassThrough_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*outData = (Data)(Out0P->outData.address);
	*outDataCnt = Out0P->outDataCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__dlPassThrough_t__defined)
#define __MIG_check__Reply__dlPassThrough_t__defined

mig_internal kern_return_t __MIG_check__Reply__dlPassThrough_t(__Reply__dlPassThrough_t *Out0P)
{

	typedef __Reply__dlPassThrough_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1157) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->outData.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->outData.size != Out0P->outDataCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__dlPassThrough_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine dlPassThrough */
mig_external kern_return_t ucsp_client_dlPassThrough
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	uint32 ssid,
	uint32 id,
	Data inData,
	mach_msg_type_number_t inDataCnt,
	Data *outData,
	mach_msg_type_number_t *outDataCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t inData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32 ssid;
		uint32 id;
		mach_msg_type_number_t inDataCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t outData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t outDataCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t outData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t outDataCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__dlPassThrough_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__dlPassThrough_t__defined */

	__DeclareSendRpc(1057, "dlPassThrough")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t inDataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->inData = inDataTemplate;
	InP->inData.address = (void *)(inData);
	InP->inData.size = inDataCnt;
#else	/* UseStaticTemplates */
	InP->inData.address = (void *)(inData);
	InP->inData.size = inDataCnt;
	InP->inData.deallocate =  FALSE;
	InP->inData.copy = MACH_MSG_VIRTUAL_COPY;
	InP->inData.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->ssid = ssid;

	InP->id = id;

	InP->inDataCnt = inDataCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1057;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1057, "dlPassThrough")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1057, "dlPassThrough")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__dlPassThrough_t__defined)
	check_result = __MIG_check__Reply__dlPassThrough_t((__Reply__dlPassThrough_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__dlPassThrough_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*outData = (Data)(Out0P->outData.address);
	*outDataCnt = Out0P->outDataCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__postNotification_t__defined)
#define __MIG_check__Reply__postNotification_t__defined

mig_internal kern_return_t __MIG_check__Reply__postNotification_t(__Reply__postNotification_t *Out0P)
{

	typedef __Reply__postNotification_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1169) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__postNotification_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine postNotification */
mig_external kern_return_t ucsp_client_postNotification
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	uint32 domain,
	uint32 event,
	Data data,
	mach_msg_type_number_t dataCnt,
	uint32 sequence
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t data;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32 domain;
		uint32 event;
		mach_msg_type_number_t dataCnt;
		uint32 sequence;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__postNotification_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__postNotification_t__defined */

	__DeclareSendRpc(1069, "postNotification")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t dataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->data = dataTemplate;
	InP->data.address = (void *)(data);
	InP->data.size = dataCnt;
#else	/* UseStaticTemplates */
	InP->data.address = (void *)(data);
	InP->data.size = dataCnt;
	InP->data.deallocate =  FALSE;
	InP->data.copy = MACH_MSG_VIRTUAL_COPY;
	InP->data.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->domain = domain;

	InP->event = event;

	InP->dataCnt = dataCnt;

	InP->sequence = sequence;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1069;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1069, "postNotification")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1069, "postNotification")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__postNotification_t__defined)
	check_result = __MIG_check__Reply__postNotification_t((__Reply__postNotification_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__postNotification_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__extractMasterKey_t__defined)
#define __MIG_check__Reply__extractMasterKey_t__defined

mig_internal kern_return_t __MIG_check__Reply__extractMasterKey_t(__Reply__extractMasterKey_t *Out0P)
{

	typedef __Reply__extractMasterKey_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1170) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->header.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->header.size != Out0P->headerCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__extractMasterKey_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine extractMasterKey */
mig_external kern_return_t ucsp_client_extractMasterKey
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db,
	Data context,
	mach_msg_type_number_t contextCnt,
	IPCDbHandle sourceDb,
	Data accessCredentials,
	mach_msg_type_number_t accessCredentialsCnt,
	Data aclEntryPrototype,
	mach_msg_type_number_t aclEntryPrototypeCnt,
	uint32 keyUsage,
	uint32 keyAttrs,
	IPCKeyHandle *key,
	Data *header,
	mach_msg_type_number_t *headerCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t context;
		mach_msg_ool_descriptor_t accessCredentials;
		mach_msg_ool_descriptor_t aclEntryPrototype;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle db;
		mach_msg_type_number_t contextCnt;
		IPCDbHandle sourceDb;
		mach_msg_type_number_t accessCredentialsCnt;
		mach_msg_type_number_t aclEntryPrototypeCnt;
		uint32 keyUsage;
		uint32 keyAttrs;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t header;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		IPCKeyHandle key;
		mach_msg_type_number_t headerCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t header;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		IPCKeyHandle key;
		mach_msg_type_number_t headerCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__extractMasterKey_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__extractMasterKey_t__defined */

	__DeclareSendRpc(1070, "extractMasterKey")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t contextTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t accessCredentialsTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t aclEntryPrototypeTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 3;
#if	UseStaticTemplates
	InP->context = contextTemplate;
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
#else	/* UseStaticTemplates */
	InP->context.address = (void *)(context);
	InP->context.size = contextCnt;
	InP->context.deallocate =  FALSE;
	InP->context.copy = MACH_MSG_VIRTUAL_COPY;
	InP->context.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->accessCredentials = accessCredentialsTemplate;
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
#else	/* UseStaticTemplates */
	InP->accessCredentials.address = (void *)(accessCredentials);
	InP->accessCredentials.size = accessCredentialsCnt;
	InP->accessCredentials.deallocate =  FALSE;
	InP->accessCredentials.copy = MACH_MSG_VIRTUAL_COPY;
	InP->accessCredentials.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->aclEntryPrototype = aclEntryPrototypeTemplate;
	InP->aclEntryPrototype.address = (void *)(aclEntryPrototype);
	InP->aclEntryPrototype.size = aclEntryPrototypeCnt;
#else	/* UseStaticTemplates */
	InP->aclEntryPrototype.address = (void *)(aclEntryPrototype);
	InP->aclEntryPrototype.size = aclEntryPrototypeCnt;
	InP->aclEntryPrototype.deallocate =  FALSE;
	InP->aclEntryPrototype.copy = MACH_MSG_VIRTUAL_COPY;
	InP->aclEntryPrototype.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->db = db;

	InP->contextCnt = contextCnt;

	InP->sourceDb = sourceDb;

	InP->accessCredentialsCnt = accessCredentialsCnt;

	InP->aclEntryPrototypeCnt = aclEntryPrototypeCnt;

	InP->keyUsage = keyUsage;

	InP->keyAttrs = keyAttrs;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1070;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1070, "extractMasterKey")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1070, "extractMasterKey")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__extractMasterKey_t__defined)
	check_result = __MIG_check__Reply__extractMasterKey_t((__Reply__extractMasterKey_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__extractMasterKey_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*key = Out0P->key;

	*header = (Data)(Out0P->header.address);
	*headerCnt = Out0P->headerCnt;

	return KERN_SUCCESS;
}

/* SimpleRoutine childCheckIn */
mig_external kern_return_t ucsp_client_childCheckIn
(
	mach_port_t sport,
	mach_port_t servicePort,
	mach_port_t task_port
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t servicePort;
		mach_msg_port_descriptor_t task_port;
		/* end of the kernel processed data */
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
	} Mess;

	Request *InP = &Mess.In;

	mach_msg_return_t msg_result;

#ifdef	__MIG_check__Reply__childCheckIn_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__childCheckIn_t__defined */

	__DeclareSendSimple(1077, "childCheckIn")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t servicePortTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		20,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t task_portTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		19,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 2;
#if	UseStaticTemplates
	InP->servicePort = servicePortTemplate;
	InP->servicePort.name = servicePort;
#else	/* UseStaticTemplates */
	InP->servicePort.name = servicePort;
	InP->servicePort.disposition = 20;
	InP->servicePort.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->task_port = task_portTemplate;
	InP->task_port.name = task_port;
#else	/* UseStaticTemplates */
	InP->task_port.name = task_port;
	InP->task_port.disposition = 19;
	InP->task_port.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 0);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = MACH_PORT_NULL;
	InP->Head.msgh_id = 1077;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendSimple(1077, "childCheckIn")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), 0, MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendSimple(1077, "childCheckIn")
	return msg_result;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__commitDbForSync_t__defined)
#define __MIG_check__Reply__commitDbForSync_t__defined

mig_internal kern_return_t __MIG_check__Reply__commitDbForSync_t(__Reply__commitDbForSync_t *Out0P)
{

	typedef __Reply__commitDbForSync_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1178) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->blob.type != MACH_MSG_OOL_DESCRIPTOR) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

#if __MigTypeCheck
	if (Out0P->blob.size != Out0P->blobCnt)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__commitDbForSync_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine commitDbForSync */
mig_external kern_return_t ucsp_client_commitDbForSync
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle srcDb,
	IPCDbHandle cloneDb,
	Pointer *blob,
	mach_msg_type_number_t *blobCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle srcDb;
		IPCDbHandle cloneDb;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t blob;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t blobCnt;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t blob;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_type_number_t blobCnt;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__commitDbForSync_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__commitDbForSync_t__defined */

	__DeclareSendRpc(1078, "commitDbForSync")

	InP->NDR = NDR_record;

	InP->srcDb = srcDb;

	InP->cloneDb = cloneDb;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1078;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1078, "commitDbForSync")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1078, "commitDbForSync")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__commitDbForSync_t__defined)
	check_result = __MIG_check__Reply__commitDbForSync_t((__Reply__commitDbForSync_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__commitDbForSync_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*blob = (Pointer)(Out0P->blob.address);
	*blobCnt = Out0P->blobCnt;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__registerHosting_t__defined)
#define __MIG_check__Reply__registerHosting_t__defined

mig_internal kern_return_t __MIG_check__Reply__registerHosting_t(__Reply__registerHosting_t *Out0P)
{

	typedef __Reply__registerHosting_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1179) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__registerHosting_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine registerHosting */
mig_external kern_return_t ucsp_client_registerHosting
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	mach_port_t hostingPort,
	uint32 flags
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t hostingPort;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32 flags;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__registerHosting_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__registerHosting_t__defined */

	__DeclareSendRpc(1079, "registerHosting")

#if	UseStaticTemplates
	const static mach_msg_port_descriptor_t hostingPortTemplate = {
		/* name = */		MACH_PORT_NULL,
		/* pad1 = */		0,
		/* pad2 = */		0,
		/* disp = */		20,
		/* type = */		MACH_MSG_PORT_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->hostingPort = hostingPortTemplate;
	InP->hostingPort.name = hostingPort;
#else	/* UseStaticTemplates */
	InP->hostingPort.name = hostingPort;
    InP->hostingPort.disposition = MACH_MSG_TYPE_COPY_SEND;
	InP->hostingPort.type = MACH_MSG_PORT_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->flags = flags;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1079;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1079, "registerHosting")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1079, "registerHosting")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__registerHosting_t__defined)
	check_result = __MIG_check__Reply__registerHosting_t((__Reply__registerHosting_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__registerHosting_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__hostingPort_t__defined)
#define __MIG_check__Reply__hostingPort_t__defined

mig_internal kern_return_t __MIG_check__Reply__hostingPort_t(__Reply__hostingPort_t *Out0P)
{

	typedef __Reply__hostingPort_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1180) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->hostingPort.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->hostingPort.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__hostingPort_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine hostingPort */
mig_external kern_return_t ucsp_client_hostingPort
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	pid_t hostPid,
	mach_port_t *hostingPort
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		pid_t hostPid;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t hostingPort;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t hostingPort;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__hostingPort_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__hostingPort_t__defined */

	__DeclareSendRpc(1080, "hostingPort")

	InP->NDR = NDR_record;

	InP->hostPid = hostPid;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1080;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1080, "hostingPort")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1080, "hostingPort")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__hostingPort_t__defined)
	check_result = __MIG_check__Reply__hostingPort_t((__Reply__hostingPort_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__hostingPort_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*hostingPort = Out0P->hostingPort.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__setGuest_t__defined)
#define __MIG_check__Reply__setGuest_t__defined

mig_internal kern_return_t __MIG_check__Reply__setGuest_t(__Reply__setGuest_t *Out0P)
{

	typedef __Reply__setGuest_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1181) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__setGuest_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine setGuest */
mig_external kern_return_t ucsp_client_setGuest
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	SecGuestRef guest,
	uint32 flags
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		SecGuestRef guest;
		uint32 flags;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__setGuest_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__setGuest_t__defined */

	__DeclareSendRpc(1081, "setGuest")

	InP->NDR = NDR_record;

	InP->guest = guest;

	InP->flags = flags;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1081;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1081, "setGuest")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1081, "setGuest")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__setGuest_t__defined)
	check_result = __MIG_check__Reply__setGuest_t((__Reply__setGuest_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__setGuest_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__createGuest_t__defined)
#define __MIG_check__Reply__createGuest_t__defined

mig_internal kern_return_t __MIG_check__Reply__createGuest_t(__Reply__createGuest_t *Out0P)
{

	typedef __Reply__createGuest_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1182) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__createGuest_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine createGuest */
mig_external kern_return_t ucsp_client_createGuest
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	SecGuestRef host,
	uint32_t status,
	FilePath path,
	HashData cdhash,
	mach_msg_type_number_t cdhashCnt,
	Data attributes,
	mach_msg_type_number_t attributesCnt,
	uint32 flags,
	SecGuestRef *guest
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t attributes;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		SecGuestRef host;
		uint32_t status;
		mach_msg_type_number_t pathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t pathCnt;
		char path[1024];
		mach_msg_type_number_t cdhashCnt;
		char cdhash[64];
		mach_msg_type_number_t attributesCnt;
		uint32 flags;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		SecGuestRef guest;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		SecGuestRef guest;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;

	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__createGuest_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__createGuest_t__defined */

	__DeclareSendRpc(1082, "createGuest")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t attributesTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->attributes = attributesTemplate;
	InP->attributes.address = (void *)(attributes);
	InP->attributes.size = attributesCnt;
#else	/* UseStaticTemplates */
	InP->attributes.address = (void *)(attributes);
	InP->attributes.size = attributesCnt;
	InP->attributes.deallocate =  FALSE;
	InP->attributes.copy = MACH_MSG_VIRTUAL_COPY;
	InP->attributes.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->host = host;

	InP->status = status;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->pathCnt = mig_strncpy_zerofill(InP->path, path, 1024);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->pathCnt = mig_strncpy(InP->path, path, 1024);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */

	msgh_size_delta = _WALIGN_(InP->pathCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 1088) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 1024);

	if (cdhashCnt > 64) {
		{ return MIG_ARRAY_TOO_LARGE; }
	}
	(void)memcpy((char *) InP->cdhash, (const char *) cdhash, cdhashCnt);

	InP->cdhashCnt = cdhashCnt;

	msgh_size_delta = _WALIGN_(cdhashCnt);
	msgh_size += msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 64);

	InP->attributesCnt = attributesCnt;

	InP->flags = flags;

	InP = &Mess.In;
	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1082;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1082, "createGuest")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1082, "createGuest")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__createGuest_t__defined)
	check_result = __MIG_check__Reply__createGuest_t((__Reply__createGuest_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__createGuest_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*guest = Out0P->guest;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__setGuestStatus_t__defined)
#define __MIG_check__Reply__setGuestStatus_t__defined

mig_internal kern_return_t __MIG_check__Reply__setGuestStatus_t(__Reply__setGuestStatus_t *Out0P)
{

	typedef __Reply__setGuestStatus_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1183) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__setGuestStatus_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine setGuestStatus */
mig_external kern_return_t ucsp_client_setGuestStatus
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	SecGuestRef guest,
	uint32_t status,
	Data attributes,
	mach_msg_type_number_t attributesCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t attributes;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		SecGuestRef guest;
		uint32_t status;
		mach_msg_type_number_t attributesCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__setGuestStatus_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__setGuestStatus_t__defined */

	__DeclareSendRpc(1083, "setGuestStatus")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t attributesTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->attributes = attributesTemplate;
	InP->attributes.address = (void *)(attributes);
	InP->attributes.size = attributesCnt;
#else	/* UseStaticTemplates */
	InP->attributes.address = (void *)(attributes);
	InP->attributes.size = attributesCnt;
	InP->attributes.deallocate =  FALSE;
	InP->attributes.copy = MACH_MSG_VIRTUAL_COPY;
	InP->attributes.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->guest = guest;

	InP->status = status;

	InP->attributesCnt = attributesCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1083;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1083, "setGuestStatus")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1083, "setGuestStatus")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__setGuestStatus_t__defined)
	check_result = __MIG_check__Reply__setGuestStatus_t((__Reply__setGuestStatus_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__setGuestStatus_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__removeGuest_t__defined)
#define __MIG_check__Reply__removeGuest_t__defined

mig_internal kern_return_t __MIG_check__Reply__removeGuest_t(__Reply__removeGuest_t *Out0P)
{

	typedef __Reply__removeGuest_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1184) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__removeGuest_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine removeGuest */
mig_external kern_return_t ucsp_client_removeGuest
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	SecGuestRef host,
	SecGuestRef guest
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		SecGuestRef host;
		SecGuestRef guest;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__removeGuest_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__removeGuest_t__defined */

	__DeclareSendRpc(1084, "removeGuest")

	InP->NDR = NDR_record;

	InP->host = host;

	InP->guest = guest;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1084;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1084, "removeGuest")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1084, "removeGuest")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__removeGuest_t__defined)
	check_result = __MIG_check__Reply__removeGuest_t((__Reply__removeGuest_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__removeGuest_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__helpCheckLoad_t__defined)
#define __MIG_check__Reply__helpCheckLoad_t__defined

mig_internal kern_return_t __MIG_check__Reply__helpCheckLoad_t(__Reply__helpCheckLoad_t *Out0P)
{

	typedef __Reply__helpCheckLoad_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1185) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__helpCheckLoad_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine helpCheckLoad */
mig_external kern_return_t ucsp_client_helpCheckLoad
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	FilePath path,
	uint32_t addType
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t pathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t pathCnt;
		char path[1024];
		uint32_t addType;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	unsigned int msgh_size;
	unsigned int msgh_size_delta;

	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__helpCheckLoad_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__helpCheckLoad_t__defined */

	__DeclareSendRpc(1085, "helpCheckLoad")

	InP->NDR = NDR_record;

#ifdef USING_MIG_STRNCPY_ZEROFILL
	if (mig_strncpy_zerofill != NULL) {
		InP->pathCnt = mig_strncpy_zerofill(InP->path, path, 1024);
	} else {
#endif /* USING_MIG_STRNCPY_ZEROFILL */
		InP->pathCnt = mig_strncpy(InP->path, path, 1024);
#ifdef USING_MIG_STRNCPY_ZEROFILL
	}
#endif /* USING_MIG_STRNCPY_ZEROFILL */

	msgh_size_delta = _WALIGN_(InP->pathCnt);
	msgh_size = (mach_msg_size_t)(sizeof(Request) - 1024) + msgh_size_delta;
	InP = (Request *) ((pointer_t) InP + msgh_size_delta - 1024);

	InP->addType = addType;

	InP = &Mess.In;
	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1085;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1085, "helpCheckLoad")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), msgh_size, (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1085, "helpCheckLoad")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__helpCheckLoad_t__defined)
	check_result = __MIG_check__Reply__helpCheckLoad_t((__Reply__helpCheckLoad_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__helpCheckLoad_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__recodeDbForSync_t__defined)
#define __MIG_check__Reply__recodeDbForSync_t__defined

mig_internal kern_return_t __MIG_check__Reply__recodeDbForSync_t(__Reply__recodeDbForSync_t *Out0P)
{

	typedef __Reply__recodeDbForSync_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1186) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__recodeDbForSync_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine recodeDbForSync */
mig_external kern_return_t ucsp_client_recodeDbForSync
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle dbToClone,
	IPCDbHandle srcDb,
	IPCDbHandle *newDb
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle dbToClone;
		IPCDbHandle srcDb;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle newDb;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle newDb;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__recodeDbForSync_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__recodeDbForSync_t__defined */

	__DeclareSendRpc(1086, "recodeDbForSync")

	InP->NDR = NDR_record;

	InP->dbToClone = dbToClone;

	InP->srcDb = srcDb;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1086;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1086, "recodeDbForSync")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1086, "recodeDbForSync")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__recodeDbForSync_t__defined)
	check_result = __MIG_check__Reply__recodeDbForSync_t((__Reply__recodeDbForSync_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__recodeDbForSync_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*newDb = Out0P->newDb;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__authenticateDbsForSync_t__defined)
#define __MIG_check__Reply__authenticateDbsForSync_t__defined

mig_internal kern_return_t __MIG_check__Reply__authenticateDbsForSync_t(__Reply__authenticateDbsForSync_t *Out0P)
{

	typedef __Reply__authenticateDbsForSync_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1187) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__authenticateDbsForSync_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine authenticateDbsForSync */
mig_external kern_return_t ucsp_client_authenticateDbsForSync
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	Data ipcDbHandleArray,
	mach_msg_type_number_t ipcDbHandleArrayCnt,
	Data agentData,
	mach_msg_type_number_t agentDataCnt,
	IPCDbHandle *newDb
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t ipcDbHandleArray;
		mach_msg_ool_descriptor_t agentData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t ipcDbHandleArrayCnt;
		mach_msg_type_number_t agentDataCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle newDb;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle newDb;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__authenticateDbsForSync_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__authenticateDbsForSync_t__defined */

	__DeclareSendRpc(1087, "authenticateDbsForSync")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t ipcDbHandleArrayTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t agentDataTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 2;
#if	UseStaticTemplates
	InP->ipcDbHandleArray = ipcDbHandleArrayTemplate;
	InP->ipcDbHandleArray.address = (void *)(ipcDbHandleArray);
	InP->ipcDbHandleArray.size = ipcDbHandleArrayCnt;
#else	/* UseStaticTemplates */
	InP->ipcDbHandleArray.address = (void *)(ipcDbHandleArray);
	InP->ipcDbHandleArray.size = ipcDbHandleArrayCnt;
	InP->ipcDbHandleArray.deallocate =  FALSE;
	InP->ipcDbHandleArray.copy = MACH_MSG_VIRTUAL_COPY;
	InP->ipcDbHandleArray.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

#if	UseStaticTemplates
	InP->agentData = agentDataTemplate;
	InP->agentData.address = (void *)(agentData);
	InP->agentData.size = agentDataCnt;
#else	/* UseStaticTemplates */
	InP->agentData.address = (void *)(agentData);
	InP->agentData.size = agentDataCnt;
	InP->agentData.deallocate =  FALSE;
	InP->agentData.copy = MACH_MSG_VIRTUAL_COPY;
	InP->agentData.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->ipcDbHandleArrayCnt = ipcDbHandleArrayCnt;

	InP->agentDataCnt = agentDataCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1087;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1087, "authenticateDbsForSync")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1087, "authenticateDbsForSync")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__authenticateDbsForSync_t__defined)
	check_result = __MIG_check__Reply__authenticateDbsForSync_t((__Reply__authenticateDbsForSync_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__authenticateDbsForSync_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*newDb = Out0P->newDb;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__verifyPrivileged_t__defined)
#define __MIG_check__Reply__verifyPrivileged_t__defined

mig_internal kern_return_t __MIG_check__Reply__verifyPrivileged_t(__Reply__verifyPrivileged_t *Out0P)
{

	typedef __Reply__verifyPrivileged_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1188) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__verifyPrivileged_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine verifyPrivileged */
mig_external kern_return_t ucsp_client_verifyPrivileged
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__verifyPrivileged_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__verifyPrivileged_t__defined */

	__DeclareSendRpc(1088, "verifyPrivileged")

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1088;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1088, "verifyPrivileged")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1088, "verifyPrivileged")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__verifyPrivileged_t__defined)
	check_result = __MIG_check__Reply__verifyPrivileged_t((__Reply__verifyPrivileged_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__verifyPrivileged_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__verifyPrivileged2_t__defined)
#define __MIG_check__Reply__verifyPrivileged2_t__defined

mig_internal kern_return_t __MIG_check__Reply__verifyPrivileged2_t(__Reply__verifyPrivileged2_t *Out0P)
{

	typedef __Reply__verifyPrivileged2_t __Reply __attribute__((unused));
	boolean_t msgh_simple;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1189) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

	msgh_simple = !(Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX);
#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((msgh_simple || Out0P->msgh_body.msgh_descriptor_count != 1 ||
	    msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	    (!msgh_simple || msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	    ((mig_reply_error_t *)Out0P)->RetCode == KERN_SUCCESS))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (msgh_simple) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

#if	__MigTypeCheck
	if (Out0P->originPort.type != MACH_MSG_PORT_DESCRIPTOR ||
	    Out0P->originPort.disposition != 17) {
		return MIG_TYPE_ERROR;
	}
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__verifyPrivileged2_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine verifyPrivileged2 */
mig_external kern_return_t ucsp_client_verifyPrivileged2
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	mach_port_t *originPort
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t originPort;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t originPort;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__verifyPrivileged2_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__verifyPrivileged2_t__defined */

	__DeclareSendRpc(1089, "verifyPrivileged2")

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1089;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1089, "verifyPrivileged2")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1089, "verifyPrivileged2")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__verifyPrivileged2_t__defined)
	check_result = __MIG_check__Reply__verifyPrivileged2_t((__Reply__verifyPrivileged2_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__verifyPrivileged2_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*originPort = Out0P->originPort.name;
	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__stashDb_t__defined)
#define __MIG_check__Reply__stashDb_t__defined

mig_internal kern_return_t __MIG_check__Reply__stashDb_t(__Reply__stashDb_t *Out0P)
{

	typedef __Reply__stashDb_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1190) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__stashDb_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine stashDb */
mig_external kern_return_t ucsp_client_stashDb
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__stashDb_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__stashDb_t__defined */

	__DeclareSendRpc(1090, "stashDb")

	InP->NDR = NDR_record;

	InP->db = db;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1090;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1090, "stashDb")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1090, "stashDb")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__stashDb_t__defined)
	check_result = __MIG_check__Reply__stashDb_t((__Reply__stashDb_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__stashDb_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__stashDbCheck_t__defined)
#define __MIG_check__Reply__stashDbCheck_t__defined

mig_internal kern_return_t __MIG_check__Reply__stashDbCheck_t(__Reply__stashDbCheck_t *Out0P)
{

	typedef __Reply__stashDbCheck_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1191) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__stashDbCheck_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine stashDbCheck */
mig_external kern_return_t ucsp_client_stashDbCheck
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__stashDbCheck_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__stashDbCheck_t__defined */

	__DeclareSendRpc(1091, "stashDbCheck")

	InP->NDR = NDR_record;

	InP->db = db;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1091;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1091, "stashDbCheck")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1091, "stashDbCheck")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__stashDbCheck_t__defined)
	check_result = __MIG_check__Reply__stashDbCheck_t((__Reply__stashDbCheck_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__stashDbCheck_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__verifyKeyStorePassphrase_t__defined)
#define __MIG_check__Reply__verifyKeyStorePassphrase_t__defined

mig_internal kern_return_t __MIG_check__Reply__verifyKeyStorePassphrase_t(__Reply__verifyKeyStorePassphrase_t *Out0P)
{

	typedef __Reply__verifyKeyStorePassphrase_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1192) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__verifyKeyStorePassphrase_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine verifyKeyStorePassphrase */
mig_external kern_return_t ucsp_client_verifyKeyStorePassphrase
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	uint32_t retries
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t retries;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__verifyKeyStorePassphrase_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__verifyKeyStorePassphrase_t__defined */

	__DeclareSendRpc(1092, "verifyKeyStorePassphrase")

	InP->NDR = NDR_record;

	InP->retries = retries;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1092;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1092, "verifyKeyStorePassphrase")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1092, "verifyKeyStorePassphrase")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__verifyKeyStorePassphrase_t__defined)
	check_result = __MIG_check__Reply__verifyKeyStorePassphrase_t((__Reply__verifyKeyStorePassphrase_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__verifyKeyStorePassphrase_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__resetKeyStorePassphrase_t__defined)
#define __MIG_check__Reply__resetKeyStorePassphrase_t__defined

mig_internal kern_return_t __MIG_check__Reply__resetKeyStorePassphrase_t(__Reply__resetKeyStorePassphrase_t *Out0P)
{

	typedef __Reply__resetKeyStorePassphrase_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1193) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__resetKeyStorePassphrase_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine resetKeyStorePassphrase */
mig_external kern_return_t ucsp_client_resetKeyStorePassphrase
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	Data passPhrase,
	mach_msg_type_number_t passPhraseCnt
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t passPhrase;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t passPhraseCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__resetKeyStorePassphrase_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__resetKeyStorePassphrase_t__defined */

	__DeclareSendRpc(1093, "resetKeyStorePassphrase")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t passPhraseTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->passPhrase = passPhraseTemplate;
	InP->passPhrase.address = (void *)(passPhrase);
	InP->passPhrase.size = passPhraseCnt;
#else	/* UseStaticTemplates */
	InP->passPhrase.address = (void *)(passPhrase);
	InP->passPhrase.size = passPhraseCnt;
	InP->passPhrase.deallocate =  FALSE;
	InP->passPhrase.copy = MACH_MSG_VIRTUAL_COPY;
	InP->passPhrase.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->passPhraseCnt = passPhraseCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1093;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1093, "resetKeyStorePassphrase")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1093, "resetKeyStorePassphrase")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__resetKeyStorePassphrase_t__defined)
	check_result = __MIG_check__Reply__resetKeyStorePassphrase_t((__Reply__resetKeyStorePassphrase_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__resetKeyStorePassphrase_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__changeKeyStorePassphrase_t__defined)
#define __MIG_check__Reply__changeKeyStorePassphrase_t__defined

mig_internal kern_return_t __MIG_check__Reply__changeKeyStorePassphrase_t(__Reply__changeKeyStorePassphrase_t *Out0P)
{

	typedef __Reply__changeKeyStorePassphrase_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1194) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__changeKeyStorePassphrase_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine changeKeyStorePassphrase */
mig_external kern_return_t ucsp_client_changeKeyStorePassphrase
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__changeKeyStorePassphrase_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__changeKeyStorePassphrase_t__defined */

	__DeclareSendRpc(1094, "changeKeyStorePassphrase")

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1094;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1094, "changeKeyStorePassphrase")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1094, "changeKeyStorePassphrase")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__changeKeyStorePassphrase_t__defined)
	check_result = __MIG_check__Reply__changeKeyStorePassphrase_t((__Reply__changeKeyStorePassphrase_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__changeKeyStorePassphrase_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__recodeDbToVersion_t__defined)
#define __MIG_check__Reply__recodeDbToVersion_t__defined

mig_internal kern_return_t __MIG_check__Reply__recodeDbToVersion_t(__Reply__recodeDbToVersion_t *Out0P)
{

	typedef __Reply__recodeDbToVersion_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1195) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__recodeDbToVersion_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine recodeDbToVersion */
mig_external kern_return_t ucsp_client_recodeDbToVersion
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	uint32 newVersion,
	IPCDbHandle srcDb,
	IPCDbHandle *newDb
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32 newVersion;
		IPCDbHandle srcDb;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle newDb;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle newDb;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__recodeDbToVersion_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__recodeDbToVersion_t__defined */

	__DeclareSendRpc(1095, "recodeDbToVersion")

	InP->NDR = NDR_record;

	InP->newVersion = newVersion;

	InP->srcDb = srcDb;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1095;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1095, "recodeDbToVersion")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1095, "recodeDbToVersion")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__recodeDbToVersion_t__defined)
	check_result = __MIG_check__Reply__recodeDbToVersion_t((__Reply__recodeDbToVersion_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__recodeDbToVersion_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*newDb = Out0P->newDb;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__cloneDb_t__defined)
#define __MIG_check__Reply__cloneDb_t__defined

mig_internal kern_return_t __MIG_check__Reply__cloneDb_t(__Reply__cloneDb_t *Out0P)
{

	typedef __Reply__cloneDb_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1196) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__cloneDb_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine cloneDb */
mig_external kern_return_t ucsp_client_cloneDb
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle srcDb,
	Data ident,
	mach_msg_type_number_t identCnt,
	IPCDbHandle *newDb
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t ident;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		IPCDbHandle srcDb;
		mach_msg_type_number_t identCnt;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle newDb;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		IPCDbHandle newDb;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__cloneDb_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__cloneDb_t__defined */

	__DeclareSendRpc(1096, "cloneDb")

#if	UseStaticTemplates
	const static mach_msg_ool_descriptor_t identTemplate = {
		/* addr = */		(void *)0,
		/* size = */		0,
		/* deal = */		FALSE,
		/* copy = */		MACH_MSG_VIRTUAL_COPY,
		/* pad2 = */		0,
		/* type = */		MACH_MSG_OOL_DESCRIPTOR,
	};
#endif	/* UseStaticTemplates */

	InP->msgh_body.msgh_descriptor_count = 1;
#if	UseStaticTemplates
	InP->ident = identTemplate;
	InP->ident.address = (void *)(ident);
	InP->ident.size = identCnt;
#else	/* UseStaticTemplates */
	InP->ident.address = (void *)(ident);
	InP->ident.size = identCnt;
	InP->ident.deallocate =  FALSE;
	InP->ident.copy = MACH_MSG_VIRTUAL_COPY;
	InP->ident.type = MACH_MSG_OOL_DESCRIPTOR;
#endif	/* UseStaticTemplates */

	InP->NDR = NDR_record;

	InP->srcDb = srcDb;

	InP->identCnt = identCnt;

	InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1096;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1096, "cloneDb")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1096, "cloneDb")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__cloneDb_t__defined)
	check_result = __MIG_check__Reply__cloneDb_t((__Reply__cloneDb_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__cloneDb_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*newDb = Out0P->newDb;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__recodeFinished_t__defined)
#define __MIG_check__Reply__recodeFinished_t__defined

mig_internal kern_return_t __MIG_check__Reply__recodeFinished_t(__Reply__recodeFinished_t *Out0P)
{

	typedef __Reply__recodeFinished_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1197) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__recodeFinished_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine recodeFinished */
mig_external kern_return_t ucsp_client_recodeFinished
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	IPCDbHandle db
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		IPCDbHandle db;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__recodeFinished_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__recodeFinished_t__defined */

	__DeclareSendRpc(1097, "recodeFinished")

	InP->NDR = NDR_record;

	InP->db = db;

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1097;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1097, "recodeFinished")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1097, "recodeFinished")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__recodeFinished_t__defined)
	check_result = __MIG_check__Reply__recodeFinished_t((__Reply__recodeFinished_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__recodeFinished_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	return KERN_SUCCESS;
}

#if ( __MigTypeCheck )
#if __MIG_check__Reply__ucsp_subsystem__
#if !defined(__MIG_check__Reply__getUserPromptAttempts_t__defined)
#define __MIG_check__Reply__getUserPromptAttempts_t__defined

mig_internal kern_return_t __MIG_check__Reply__getUserPromptAttempts_t(__Reply__getUserPromptAttempts_t *Out0P)
{

	typedef __Reply__getUserPromptAttempts_t __Reply __attribute__((unused));
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	if (Out0P->Head.msgh_id != 1198) {
	    if (Out0P->Head.msgh_id == MACH_NOTIFY_SEND_ONCE)
		{ return MIG_SERVER_DIED; }
	    else
		{ return MIG_REPLY_MISMATCH; }
	}

#if	__MigTypeCheck
	msgh_size = Out0P->Head.msgh_size;

	if ((Out0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    ((msgh_size != (mach_msg_size_t)sizeof(__Reply)) &&
	     (msgh_size != (mach_msg_size_t)sizeof(mig_reply_error_t) ||
	      Out0P->RetCode == KERN_SUCCESS)))
		{ return MIG_TYPE_ERROR ; }
#endif	/* __MigTypeCheck */

	if (Out0P->RetCode != KERN_SUCCESS) {
		return ((mig_reply_error_t *)Out0P)->RetCode;
	}

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Reply__getUserPromptAttempts_t__defined) */
#endif /* __MIG_check__Reply__ucsp_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine getUserPromptAttempts */
mig_external kern_return_t ucsp_client_getUserPromptAttempts
(
	mach_port_t sport,
	mach_port_t rport,
	security_token_t *securitydCreds,
	CSSM_RETURN *rcode,
	uint32_t *attempts
)
{

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		uint32_t attempts;
		mach_msg_max_trailer_t trailer;
	} Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		CSSM_RETURN rcode;
		uint32_t attempts;
	} __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	union {
		Request In;
		Reply Out;
	} Mess;

	Request *InP = &Mess.In;
	Reply *Out0P = &Mess.Out;

	mach_msg_return_t msg_result;
	mach_msg_max_trailer_t *TrailerP;
#if	__MigTypeCheck
	unsigned int trailer_size;
#endif	/* __MigTypeCheck */

#ifdef	__MIG_check__Reply__getUserPromptAttempts_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Reply__getUserPromptAttempts_t__defined */

	__DeclareSendRpc(1098, "getUserPromptAttempts")

	InP->Head.msgh_bits =
		MACH_MSGH_BITS(19, 20);
	/* msgh_size passed as argument */
	InP->Head.msgh_request_port = sport;
	InP->Head.msgh_reply_port = rport;
	InP->Head.msgh_id = 1098;
	InP->Head.msgh_reserved = 0;
	
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
	if (voucher_mach_msg_set != NULL) {
		voucher_mach_msg_set(&InP->Head);
	}
#endif // USING_VOUCHERS
	
/* END VOUCHER CODE */

	__BeforeSendRpc(1098, "getUserPromptAttempts")
	msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_MSG_OPTION_NONE|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_SENDER), (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	__AfterSendRpc(1098, "getUserPromptAttempts")
	if (msg_result != MACH_MSG_SUCCESS) {
		{ return msg_result; }
	}


#if	defined(__MIG_check__Reply__getUserPromptAttempts_t__defined)
	check_result = __MIG_check__Reply__getUserPromptAttempts_t((__Reply__getUserPromptAttempts_t *)Out0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ return check_result; }
#endif	/* defined(__MIG_check__Reply__getUserPromptAttempts_t__defined) */

	TrailerP = (mach_msg_max_trailer_t *)((vm_offset_t)Out0P +
		round_msg(Out0P->Head.msgh_size));
	if (TrailerP->msgh_trailer_type != MACH_MSG_TRAILER_FORMAT_0)
		{ return MIG_TRAILER_ERROR ; }
#if	__MigTypeCheck
	trailer_size = TrailerP->msgh_trailer_size -
		(mach_msg_size_t)(sizeof(mach_msg_trailer_type_t) - sizeof(mach_msg_trailer_size_t));
#endif	/* __MigTypeCheck */
#if	__MigTypeCheck
	if (trailer_size < (mach_msg_size_t)sizeof(security_token_t))
		{ return MIG_TRAILER_ERROR ; }
	trailer_size -= (mach_msg_size_t)sizeof(security_token_t);
#endif	/* __MigTypeCheck */

	*securitydCreds = TrailerP->msgh_sender;

	*rcode = Out0P->rcode;

	*attempts = Out0P->attempts;

	return KERN_SUCCESS;
}
